<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AdaptiveDensityApproximation · AntibodyMethodsDoseResponse</title><meta name="title" content="AdaptiveDensityApproximation · AntibodyMethodsDoseResponse"/><meta property="og:title" content="AdaptiveDensityApproximation · AntibodyMethodsDoseResponse"/><meta property="twitter:title" content="AdaptiveDensityApproximation · AntibodyMethodsDoseResponse"/><meta name="description" content="Documentation for AntibodyMethodsDoseResponse."/><meta property="og:description" content="Documentation for AntibodyMethodsDoseResponse."/><meta property="twitter:description" content="Documentation for AntibodyMethodsDoseResponse."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="AntibodyMethodsDoseResponse logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AntibodyMethodsDoseResponse</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../QuickStart/">Quick start</a></li><li><span class="tocitem">Detailed explanations</span><ul><li><a class="tocitem" href="../MeasurementData/">Measurement data</a></li><li><a class="tocitem" href="../Models/">Models</a></li><li><a class="tocitem" href="../ResultsAndSimulations/">Results and simulations</a></li><li><a class="tocitem" href="../DensityPlots/">Density plots for <code>OneDimGrid</code></a></li><li><a class="tocitem" href="../Fitting/">Fitting</a></li><li><a class="tocitem" href="../Uncertainty/">Uncertainty estimation</a></li></ul></li><li><span class="tocitem">FittingObjectiveFunctions</span><ul><li><a class="tocitem" href="../FittingObjectiveFunctions/">Introduction</a></li><li><a class="tocitem" href="../FittingObjectiveFunctions/fitting_data/">FittingData and ModelFunctions</a></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Least squares objective</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../FittingObjectiveFunctions/lsq_background/">Background</a></li><li><a class="tocitem" href="../FittingObjectiveFunctions/lsq_implementation/">How to implement</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Posterior probability</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../FittingObjectiveFunctions/posterior_background/">Background</a></li><li><a class="tocitem" href="../FittingObjectiveFunctions/posterior_implementation/">How to implement</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Logarithmic posterior probability</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../FittingObjectiveFunctions/log_posterior_background/">Background</a></li><li><a class="tocitem" href="../FittingObjectiveFunctions/log_posterior_implementation/">How to implement</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href>AdaptiveDensityApproximation</a><ul class="internal"><li><a class="tocitem" href="#About"><span>About</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#1-dim-example"><span>1-dim example</span></a></li><li><a class="tocitem" href="#Simple-2-dim-example"><span>Simple 2-dim example</span></a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/">AntibodyMethodsDoseResponse</a></li><li><a class="tocitem" href="../API_Convenience/">AntibodyMethodsDoseResponseConvenience</a></li><li><a class="tocitem" href="../FittingObjectiveFunctions/API/">FittingObjectiveFunctions</a></li><li><a class="tocitem" href="api/">AdaptiveDensityApproximation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AdaptiveDensityApproximation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AdaptiveDensityApproximation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AntibodyPackages/AntibodyMethodsDoseResponse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AntibodyPackages/AntibodyMethodsDoseResponse/blob/main/docs/src/AdaptiveDensityApproximation/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="AdaptiveDensityApproximation"><a class="docs-heading-anchor" href="#AdaptiveDensityApproximation">AdaptiveDensityApproximation</a><a id="AdaptiveDensityApproximation-1"></a><a class="docs-heading-anchor-permalink" href="#AdaptiveDensityApproximation" title="Permalink"></a></h1><h2 id="About"><a class="docs-heading-anchor" href="#About">About</a><a id="About-1"></a><a class="docs-heading-anchor-permalink" href="#About" title="Permalink"></a></h2><p>This package introduces the <code>Grid</code> and <code>OneDimGrid</code> types that approximate density functions. The grids can be refined adaptively, i.e. depending on the  location of the strongest density variation. Simple calculations like sums and products of approximated coefficients and integrals of approximated densities are implemented.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This package is not in the general registry and needs to be installed from the GitHub repository by:</p><pre><code class="language- hljs">using Pkg
Pkg.add(url=&quot;https://github.com/AntibodyPackages/AdaptiveDensityApproximation&quot;)</code></pre><p>After the installation, the package can be used like any other package:</p><pre><code class="language-julia hljs">using AdaptiveDensityApproximation</code></pre><div class="admonition is-success"><header class="admonition-header">Tip: Plotting grids</header><div class="admonition-body"><p>This package does not include any plotting methods, to reduce the dependencies. However, the package <code>AdaptiveDensityApproximationRecipes</code> contains plotting recipes for <code>Plots.jl</code>. Again, the package is not in the general registry and needs to be installed from the GitHub repository:</p><pre><code class="language- hljs">using Pkg
Pkg.add(url=&quot;https://github.com/AntibodyPackages/AdaptiveDensityApproximationRecipes&quot;)</code></pre></div></div><h2 id="1-dim-example"><a class="docs-heading-anchor" href="#1-dim-example">1-dim example</a><a id="1-dim-example-1"></a><a class="docs-heading-anchor-permalink" href="#1-dim-example" title="Permalink"></a></h2><p>In the following, the methods of this package are illustrated on simple, 1-dimensional examples. In some but not all cases tips and additional information are given. For a full documentation of the methods, see the <a href="api/">API</a></p><h3 id="Construct-grid-and-approximate-densities"><a class="docs-heading-anchor" href="#Construct-grid-and-approximate-densities">Construct grid and approximate densities</a><a id="Construct-grid-and-approximate-densities-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-grid-and-approximate-densities" title="Permalink"></a></h3><p>The first step is to create a new one-dimensional grid. For this, axis-ticks need to be defined, i.e. the start/endpoints of the intervals:</p><pre><code class="language-julia hljs">using AdaptiveDensityApproximation, AdaptiveDensityApproximationRecipes, Plots
grid = create_grid(LinRange(0,2*pi,10))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveDensityApproximation.OneDimGrid{Dict{String, AdaptiveDensityApproximation.OneDimBlock}}(Dict{String, AdaptiveDensityApproximation.OneDimBlock}(&quot;s7Rq97Jtsi&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;s7Rq97Jtsi&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.3962634015954636, 2.0943951023931953), [&quot;hWNTnwHa1I&quot;, &quot;mIGM4FWLLV&quot;], 1.0), &quot;JA9URA8qlH&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;JA9URA8qlH&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.0, 0.6981317007977318), [&quot;hWNTnwHa1I&quot;], 1.0), &quot;hWNTnwHa1I&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;hWNTnwHa1I&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.6981317007977318, 1.3962634015954636), [&quot;JA9URA8qlH&quot;, &quot;s7Rq97Jtsi&quot;], 1.0), &quot;wweM2Kvpua&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;wweM2Kvpua&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(4.1887902047863905, 4.886921905584122), [&quot;LY5NKGoLva&quot;, &quot;bRTrwiriUG&quot;], 1.0), &quot;bRTrwiriUG&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;bRTrwiriUG&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(4.886921905584122, 5.585053606381854), [&quot;wweM2Kvpua&quot;, &quot;AtlQExMOic&quot;], 1.0), &quot;2lIIqlfvDG&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;2lIIqlfvDG&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(2.792526803190927, 3.490658503988659), [&quot;mIGM4FWLLV&quot;, &quot;LY5NKGoLva&quot;], 1.0), &quot;mIGM4FWLLV&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;mIGM4FWLLV&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(2.0943951023931953, 2.792526803190927), [&quot;s7Rq97Jtsi&quot;, &quot;2lIIqlfvDG&quot;], 1.0), &quot;LY5NKGoLva&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;LY5NKGoLva&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(3.490658503988659, 4.1887902047863905), [&quot;2lIIqlfvDG&quot;, &quot;wweM2Kvpua&quot;], 1.0), &quot;AtlQExMOic&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;AtlQExMOic&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(5.585053606381854, 6.283185307179586), [&quot;bRTrwiriUG&quot;], 1.0)))</code></pre><p>The grid can be used to approximate a function <code>f</code> with <code>approximate_density!(grid,f)</code>:</p><pre><code class="language-julia hljs">approximate_density!(grid,sin)
plot(grid)
plot!(sin,color = :red, xlims = [0,2*pi], linewidth = 3)</code></pre><img src="index-af4d1eca.svg" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip: Approximation options</header><div class="admonition-body"><p>The density is approximated by evaluating the function <code>f</code> at the center points of the grid. But in some cases, it can be desireable to approximate the density using different evaluation points. The following keywords allow to modify the approximation points:</p><ul><li><code>mode = :mean</code>: Use the average from the endpoints of the interval / corner points of the block.</li><li><code>mode = :mesh</code>: Use the average from a mesh of intermediate points.</li><li><code>mesh_size = n</code>: If <code>mode = :mesh</code> use <code>n</code> intermediate points (per dimension). The default is 4.</li></ul><p>It is also possible to approximate the area under the graph of a density (function value × block volume) by using <code>volume_normalization = true</code>.</p></div></div><h3 id="Accessing-information-of-the-grid"><a class="docs-heading-anchor" href="#Accessing-information-of-the-grid">Accessing information of the grid</a><a id="Accessing-information-of-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-information-of-the-grid" title="Permalink"></a></h3><p>Essentially, a grid is just a collection of values (the weights), together with location information (the blocks of the grid). This data can be exported to allow for a convenient implementation of advanced calculations not covered by this package. The weights can be retrieved by</p><pre><code class="language-julia hljs">export_weights(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Float64}:
  0.3420201433256687
  0.8660254037844386
  0.9848077530122081
  0.6427876096865395
  1.2246467991473532e-16
 -0.6427876096865393
 -0.984807753012208
 -0.866025403784439
 -0.3420201433256686</code></pre><p>Alternatively, the full information can be exported:</p><pre><code class="language-julia hljs">centers, volumes, weights = export_all(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.3490658503988659, 1.0471975511965976, 1.7453292519943293, 2.443460952792061, 3.141592653589793, 3.839724354387525, 4.537856055185257, 5.235987755982988, 5.934119456780721], [0.6981317007977318, 0.6981317007977318, 0.6981317007977317, 0.6981317007977319, 0.6981317007977319, 0.6981317007977315, 0.6981317007977319, 0.6981317007977319, 0.6981317007977319], [0.3420201433256687, 0.8660254037844386, 0.9848077530122081, 0.6427876096865395, 1.2246467991473532e-16, -0.6427876096865393, -0.984807753012208, -0.866025403784439, -0.3420201433256686])</code></pre><p>The reverse direction, the import of weights is is also possible (at least for the weights):</p><pre><code class="language-julia hljs">import_weights!(grid, collect(1:9))
plot(grid)</code></pre><img src="index-96d0023b.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Order of blocks</header><div class="admonition-body"><p>For export and import, the intervals/blocks are ordered by their center point. For multidimensional grids, the order is component wise (first dimension precedes second dimension precedes third dimension ...).</p></div></div><h3 id="Refine-the-grid"><a class="docs-heading-anchor" href="#Refine-the-grid">Refine the grid</a><a id="Refine-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Refine-the-grid" title="Permalink"></a></h3><p>The grid can be refined (subdividing the blocks that have the largest weight differences to their neighbors) with:</p><pre><code class="language-julia hljs">refine!(grid)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>A block is subdivided into 2^dim equally-sized subdividing blocks. E.g. an interval is split in the middle into two intervals, a square is split into 4 quatring squares, etc.. </p></div></div><p>The functions <code>approximate_density!</code> and <code>refine!</code> can be used together in a loop to refine the grid adaptively.</p><pre><code class="language-julia hljs">grid = create_grid([0,pi/2,pi,3*pi/2,2*pi])

animation = @animate for i in 1:30
	plot(grid)
	approximate_density!(grid,sin)
	refine!(grid)
end
gif(animation,fps=2)</code></pre><img src="index-ca857846.gif" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip: Custom variation and block selection</header><div class="admonition-body"><p>The refine process is a two-step process. First, each block is assigned a variation value. The default variation is the largest absolut weight difference to the neighboring blocks. Then, based on the variation values, the blocks that will be subdivided further are selected (largest variation value by default). It is possible to redefine the block variation assignment and the selection:</p><ul><li><code>block_variation</code>: Function to calculate the variation value for a block. Must use the following signature <code>(block_center,block_volume, block_weight, neighbor_center,neighbor_volumes, neighbor_weights)</code>.</li><li><code>selection</code>: Function to select the appropriate variation value(s) from. Must have the signature <code>(variations)</code>  where variations is a one-dim array of the variation values.</li></ul></div></div><div class="admonition is-info"><header class="admonition-header">Weight splitting</header><div class="admonition-body"><p>The subdividing blocks retain the weight of the original block. If <code>split_weights = true</code>, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).</p></div></div><h3 id="Restriction-of-grid-domain"><a class="docs-heading-anchor" href="#Restriction-of-grid-domain">Restriction of grid domain</a><a id="Restriction-of-grid-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Restriction-of-grid-domain" title="Permalink"></a></h3><p>For some applications it can be useful to restrict a grid (temporarily) for certain calculations. Consider, for example, a grid that approximates <code>x-&gt;x^2</code> on the domain <code>[-1,1]</code>:</p><pre><code class="language-julia hljs">grid = create_grid(LinRange(-1,1,50))
approximate_density!(grid,x-&gt; x^2)
plot(grid)</code></pre><img src="index-8c4fe6a9.svg" alt="Example block output"/><p>A reasonable domain restriction could be to only allow positive numbers for <code>x</code>, i.e. to restrict the grid to <code>[0,1]</code>:</p><pre><code class="language-julia hljs">restrict_domain!(grid,lower = 0)
plot(grid)</code></pre><img src="index-b1ee45dc.svg" alt="Example block output"/><h3 id="Simple-calculations:-Sums,-products-and-integrals"><a class="docs-heading-anchor" href="#Simple-calculations:-Sums,-products-and-integrals">Simple calculations: Sums, products and integrals</a><a id="Simple-calculations:-Sums,-products-and-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-calculations:-Sums,-products-and-integrals" title="Permalink"></a></h3><p>Some simple operations are pre-defined for grids (no need to export weights, etc.). For example, the sum of the weights can easily be obtained:</p><pre><code class="language-julia hljs">sum(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8.16326530612245</code></pre><p>It is also possible to apply a function to all weights before they get summed up / get multiplied together. Furthermore, the grid domain can be restricted temporarily (not mutating the grid).</p><pre><code class="language-julia hljs">prod(x-&gt; log(x),grid, lower = 0.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-5.446594287627767e-5</code></pre><p>A grid can also be used for the approximation of an integral. In the case of the restricted grid from above, approximating <span>$x\mapsto x^2$</span> on <span>$[0,1]$</span>, the integral <span>$\int_0^{1} x^2\ dx \overset{!}{=} \frac{1}{3}$</span> is approximated:</p><pre><code class="language-julia hljs">integrate(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3331945022907121</code></pre><h3 id="Advanced-calculations:-Integral-models"><a class="docs-heading-anchor" href="#Advanced-calculations:-Integral-models">Advanced calculations: Integral models</a><a id="Advanced-calculations:-Integral-models-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-calculations:-Integral-models" title="Permalink"></a></h3><p>A more flexible method of integration is the construction of integral models. Consider the general model</p><p class="math-container">\[	\int f(x,\tau,\varphi(\tau),...) \ d\tau\]</p><p>for a density function <span>$\varphi$</span>. When the density function is approximated by a grid, i.e. by intervals <span>$I_j$</span> with centers <span>$c(I_j)$</span>, volumes <span>$\text{vol}(I_j)$</span> and heights <span>$h(I_j)\approx \varphi(c(I_j))$</span>, the model can be approximated with</p><p class="math-container">\[	\int f(x,\tau,\varphi(\tau),...) \ d\tau \approx \sum_{j} f(x,c(I_j), h(I_j),\ldots)\cdot \text{vol}(I_j) \ .\]</p><p>In general, the implementation of such a model requires a function <code>f(x,τ,φ(τ),...)</code> and a grid that approximates the density <code>φ</code>. The model can then be obtained with <code>integral_model(grid,f)</code>. More precisely:</p><div style=" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px "><div class="markdown"><pre><code>integral_model&#40;grid,f::Function, g::Function &#61; f&#41;</code></pre>
<p>Create a model for the integral <code>∫_grid f&#40;x,y,φ&#40;y&#41;,...&#41; dy</code>. Returns</p>
<ul>
<li><p>model function: <code>&#40;x,λ,args...&#41; -&gt; ∑_i block&#91;i&#93;.volume × f&#40;x,block&#91;i&#93;.center,λ&#91;i&#93;,args...&#41;</code></p>
</li>
<li><p>initial parameter based on block weights: <code>λ_0 &#61; &#91;block.weight for block in grid&#93;</code></p>
</li>
<li><p>components of the sum as array of functions: <code>&#91;&#40;x,λ,args...&#41; -&gt; block&#91;i&#93;.volume × g&#40;x,block&#91;i&#93;.center,λ&#91;i&#93;,args...&#41; for i&#93;</code></p>
</li>
</ul>
<p>The functions <code>f</code> and <code>g</code> should have the arguments <code>&#40;x,center,weight,args...&#41;</code>.  </p>
<p><strong>Partial derivatives</strong></p>
<p>The optional function <code>g</code> can be used to obtain the partial derivatives of the model function w.r.t. <code>λ</code> as array of functions. For this, construct <code>g</code> such that</p>
<pre><code>g&#40;x,c,w&#41; &#61; ∂_w f&#40;x,c,w&#41;</code></pre>


</div></div> <br><p>For example, consider <code>f(x,τ,φ(τ)) = cos(τ * x) * φ(τ)</code> for <code>φ(τ) = sin(τ)</code> on <code>[0,2π]</code>:</p><p class="math-container">\[\int_0^{2\pi} \cos(\tau\cdot x)  \cdot \text{sin}(\tau) \ d\tau \ .\]</p><p>In particular, it holds that:</p><p class="math-container">\[\int_0^{2\pi} \cos(\tau\cdot 1)  \cdot \text{sin}(\tau) \ d\tau = 0\ .\]</p><pre><code class="language-julia hljs">grid = create_grid(LinRange(0,2*pi,30))
approximate_density!(grid,sin)
f(x,τ,φ) = cos(τ*x)*φ
model,weights, components = integral_model(grid,f)
model(1,weights)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-6.938893903907228e-18</code></pre><h3 id="Numeric-PDF-and-CDF"><a class="docs-heading-anchor" href="#Numeric-PDF-and-CDF">Numeric PDF and CDF</a><a id="Numeric-PDF-and-CDF-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-PDF-and-CDF" title="Permalink"></a></h3><p>When the grid approximates a probability density, i.e. a positive density function, numeric PDF anc CDF functions can be obtained as julia functions.</p><pre><code class="language-julia hljs">p(x) = 1/sqrt(2*pi) * exp(-x^2/2)
grid = create_grid(LinRange(-10,10,100))
approximate_density!(grid,p)
plot(grid)</code></pre><img src="index-af87ef09.svg" alt="Example block output"/><p>The numeric pdf can be obtained with </p><div style=" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px "><div class="markdown"><pre><code>get_pdf&#40;grid;normalize::Bool &#61; true&#41;</code></pre>
<p>Return the discrete empirical pdf function of a grid. For this, the grid is understood as histogram, where the blocks are the bins, and the weights are the corresponding values. If <code>normalize &#61; true</code> the values are normalized s.t. the sum of all values is 1.</p>


</div></div> <br><p>The numeric cdf can be obtained with </p><div style=" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px "><div class="markdown"><pre><code>get_cdf&#40;grid;normalize::Bool &#61; true&#41;</code></pre>
<p>Return the discrete empirical cdf function of a grid. For this, the grid is understood as histogram, where the blocks are the bins, and the weights are the corresponding values. If <code>normalize &#61; true</code> the values are normalized s.t. the sum of all values is 1.</p>


</div></div> <br><p>For example:</p><pre><code class="language-julia hljs">cdf = get_cdf(grid)

plot(cdf, fill = 0, legend = :none)</code></pre><img src="index-7f226d6e.svg" alt="Example block output"/><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The function <code>get_pdf</code> and <code>get_cdf</code> do not check if the weights of the blocks are positive. Negative values can lead to unexpected behavior, e.g. division by zero because of the normalization <code>1/sum(weights)</code>.</p></div></div><h2 id="Simple-2-dim-example"><a class="docs-heading-anchor" href="#Simple-2-dim-example">Simple 2-dim example</a><a id="Simple-2-dim-example-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-2-dim-example" title="Permalink"></a></h2><p>In general, the methods introduced so far are defined for grids of arbitrary dimensions (except for plotting recipes):</p><pre><code class="language-julia hljs">using AdaptiveDensityApproximation, Plots

grid = create_grid([0,pi,2*pi],[0,pi,2pi])
f(x) = sin(x[1])^2 + cos(x[2])^2

animation = @animate for i in 1:100
	plot(grid)
	approximate_density!(grid,f)
	refine!(grid)
end
gif(animation, fps = 4)</code></pre><p><img src="images/simple-2-dim-example.gif" alt/></p><p>It is possible to get a lower-dimensional slice from a higher-dimensional grid (slice along the <code>x</code>-axis at <code>y=3</code> in this case):</p><pre><code class="language-julia hljs">slice = get_slice(grid,[nothing,3])
plot(slice)</code></pre><img src="index-2ba9a4cc.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../FittingObjectiveFunctions/log_posterior_implementation/">« How to implement</a><a class="docs-footer-nextpage" href="../API/">AntibodyMethodsDoseResponse »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 10 July 2024 21:21">Wednesday 10 July 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
