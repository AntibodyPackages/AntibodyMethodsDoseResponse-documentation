var documenterSearchIndex = {"docs":
[{"location":"FittingObjectiveFunctions/log_posterior_implementation/#Logarithmic-posterior-probability:-How-to-implement","page":"How to implement","title":"Logarithmic posterior probability: How to implement","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"Consider the data and model from Simple-example:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"using FittingObjectiveFunctions, Plots #hide\n\nX = collect(1:10)\nY = [1.0, 1.78, 3.64, 3.72, 5.33, 2.73, 7.52, 9.19, 6.73, 8.95]\nΔY = [0.38, 0.86, 0.29, 0.45, 0.66, 2.46, 0.39, 0.45, 1.62, 1.54]\nmodel = ModelFunctions((x,λ)-> λ*x)\n\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/#Log-likelihood-and-log-posterior","page":"How to implement","title":"Log-likelihood and log-posterior","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"The general procedure to obtain the log-likelihood and log-posterior functions is the same as described in Posterior-probability:-How-to-implement. However, the distributions and the prior need to be in logarithmic form, such that the default distributions of the FittingData constructor do not work.  Thus, we need to define a FittingData object with logarithmic distributions:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"using Distributions\ndata_log_dists = FittingData(X,Y,ΔY,distributions = (y,m,Δy)-> logpdf(Normal(m,Δy),y))\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"The log-likelihood function can be obtained by using the log_posterior_objective function:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"log_likelihood = log_posterior_objective(data_log_dists,model)\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"As described in Using-priors, the likelihood is obtained by using the prior λ-> 1 (or in the logarithmic case λ-> 0). Again, this is what happens in the background. To use prior, it just needs to be passed as third argument:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"log_posterior = log_posterior_objective(data_log_dists,model, λ-> logpdf(Normal(1,0.1),λ))\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"The resulting functions can be compared by adjusting the constant offset (see Logarithmic scale)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"large_scope = plot(x-> log_likelihood(x) + 1.105, xlims = [0.9,1.2], label = \"log_likelihood\", legend = :topleft) #hide\nplot!(log_posterior, label = \"log_posterior\")  #hide\nsmall_scope = plot(x-> log_likelihood(x) + 1.105, xlims = [1.065,1.085], legend = :none) #hide\nplot!(log_posterior)  #hide\nplot(large_scope,small_scope, layout = (1,2), size = (800,300)) #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/#Application:-Regularized-least-squares","page":"How to implement","title":"Application: Regularized least squares","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"Recall the weighted least squares objective from LSQ:-How-to-implement","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"lsq = lsq_objective(data_log_dists, model)\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"Note that the distributions field of data_log_dists has no effect on least squares objectives. ","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"To replicate the least squares objective, unnormalized logarithmic distributions can be used:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"data_lsq_dists = FittingData(X,Y,ΔY, distributions = (y,m,Δy)-> -(y-m)^2/Δy^2)\nlsq_likelihood = log_posterior_objective(data_lsq_dists,model)\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"plot(lsq, label = \"lsq\") #hide\nplot!(lsq_likelihood, label = \"lsq_likelihood\") #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"The lsq_likelihood is the same function as lsq, but with the opposite sign (because it is a logarithmic unnormalized posterior probability density). This could either be fixed by using λ -> -lsq_likelihood(λ), or in this case by using distributions = (y,m,Δy)-> -(y-m)^2/Δy^2.","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"Now, a regularization can be implemented by using a corresponding logarithmic prior:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"lsq_posterior = log_posterior_objective(data_lsq_dists,model, λ -> - λ^2)\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/#Derivatives","page":"How to implement","title":"Derivatives","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"Analytical derivatives can be obtained almost in the same way as described in LSQ:-partial-derivatives-and-gradients:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/#Partial-derivatives","page":"How to implement","title":"Partial derivatives","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"@doc log_posterior_partials #hide","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/#Gradient","page":"How to implement","title":"Gradient","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_implementation/","page":"How to implement","title":"How to implement","text":"@doc log_posterior_gradient #hide","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/#FittingData-and-ModelFunctions","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"","category":"section"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"using FittingObjectiveFunctions #hide\nmodel = ModelFunctions((x,λ) -> λ*x) #hide\nX = collect(1:10) #hide\nY = [1.0, 1.78, 3.64, 3.72, 5.33, 2.73, 7.52, 9.19, 6.73, 8.95] #hide\nΔY = [0.38, 0.86, 0.29, 0.45, 0.66, 2.46, 0.39, 0.45, 1.62, 1.54] #hide\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"In the Simple-example, it was already mentioned that the data needs to be summarized in a FittingData object and that information about the model needs to be summarized in a ModelFunctions object. The details about these data types are discussed here.","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/#FittingData","page":"FittingData and ModelFunctions","title":"FittingData","text":"","category":"section"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"FittingData objects have the following general constructor:","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"data = FittingData(X,Y,ΔY, distributions = distribution_functions)","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"The resulting object has the following fields:","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"data.independent == X\ndata.dependent == Y\ndata.errors == ΔY\ndata.distributions == distributions_functions","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"tip: Tip: shortened constructors\nIf no measurement errors ΔY are available, one can use the shortened constructorFittingData(X,Y, distributions = distribution_functions)In this case, the default errors ones(length(X)) are used (leading e.g. to the standard least squares objective function: Background:-LSQ)","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"tip: Tip: distributions\nThe optional distributions keyword is used to specify the likelihood distributions (see Background:-Posterior-probability). In case distributions are not specified, the constructor defaults to normal distributions.The distributions can be specified as an array of functions, or a single function (if the same distribution shall be used for all data points) with the signature (y,m,Δy), wherey is the measured dependent variable\nΔy is the corresponding error\nm are values the model function returns, when the parameters are varied, i.e. m(x,λ).","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/#ModelFunctions","page":"FittingData and ModelFunctions","title":"ModelFunctions","text":"","category":"section"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"ModelFunctions objects have the following general constructor:","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"model = ModelFunctions(model_function, partial_derivatives = [derivative_functions...])","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"The resulting object has the following fields:","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"model.model == model_function\nmodel.partials == [derivative_functions...]","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"The model function (and the partial derivatives) must have the signature (x,λ), where x is the independent variable and λ is the parameter(array).","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"tip: Tip: Partial derivatives\nThe keyword partials is optional, but is required for analytical partial derivatives and analytical gradient functions. The partial derivatives w.r.t. to the parameter are defined as array of functions.textm(xlambda) = lambda_1 x + lambda_2  quad fracpartial textm(xlambda)partial lambda_1  = x  quad fracpartial textm(xlambda)partial lambda_1 = 1ModelFunctions((x,λ)-> λ[1]*x + λ[2], partials = [(x,λ)-> x, (x,λ)-> 1])","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/#Additional-remarks","page":"FittingData and ModelFunctions","title":"Additional remarks","text":"","category":"section"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"When a FittingObject/ModelFunctions object is created, some rudimentary consistency checks are made, e.g. that all arrays have the same lengths.","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"FittingData([1,2,3],[1,2],[1,1,1])","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"Since the objects are mutable, the same consistency checks are repeated before objective functions are created. However, it can be useful to make a comprehensive consistency check. For this, an exemplary parameter (array) is needed:","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"data = FittingData(X,Y)\nmodel = ModelFunctions((x,λ)-> λ*x)\nconsistency_check(data,model,1)","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"If everything works, nothing is returned, i.e. nothing happens. However, in case of a problem, an error is thrown:","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"consistency_check(data,model,\"1\")","category":"page"},{"location":"FittingObjectiveFunctions/fitting_data/","page":"FittingData and ModelFunctions","title":"FittingData and ModelFunctions","text":"note: Mutability of objects\nBoth FittingData objects and ModelFunction objects are mutable for convenience, as they are not performance relevant (only their fields are). However, when objective functions are created, the object fields are copied and enclosed in the objective function, to avoid accidental mutation. I.e. once an objective function is created, it does not change, even if the FittingData/ModelFunctions objects are changed. To apply changes, a new objective function has to be created. ","category":"page"},{"location":"Models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"Models/#binding_models","page":"Models","title":"Binding models","text":"","category":"section"},{"location":"Models/","page":"Models","title":"Models","text":"This package provides 2 binding model kernels:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"textAccumulationquad  x(a) = g(1-e^-fracaK_tau)qquad textandqquad textLangmuir isothermquad x(a) = fracg1+fracK_da","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"The Langmuir isotherm describes the equilibrium of binding (with rate k_texton) and unbinding (with rate k_textoff) of antibodies, which is characterized by the dissociation constant K_d = frack_textoffk_texton.\nThe accumulation model describes the accumulation of antibodies (with rate k_texton) during the incubation time tau, which is characterized by the accessibility limitation constant K_tau = frac1k_textoncdot tau.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"tip: Jovanovic isotherm\nThe accumulation model resembles the Jovanovic isotherm structurally. However, the Jovanovic isotherm describes an equilibrium of binding and unbinding processes, whereas the accumulation model describes the accumulation over time, which is stopped at a finite time tau before reaching the saturation. Nevertheless, because of the structural similarity, the accumulation model can be used as drop-in replacement to analyze equilibrium data with the Jovanovic isotherm.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Both model kernels are used for the rate constant distribution approach (Svitel et al. 2003):","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"beginaligned\ntextAccumulation model quad x(a) = int_0^infty g(k)(1-e^-fracak) dk\ntextLangmuir model quad  x(a) = int_0^infty fracg(k)1+fracka  dk \nendaligned","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"In both cases, the density g(k) describes the number of epitopes that exhibit the respective constant k (accessibility limitation / dissociation depending on the model). The density approach models the superposition of different classes of epitopes being present in the system at the same time (e.g. in complex cellular systems).","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"info: Default model\nThe accumulation model is set as default model for all methods in this package. Accordingly this documentation describes most terms, results, interpretations from the perspective of the accumulation model.","category":"page"},{"location":"Models/#Integral-approximation","page":"Models","title":"Integral approximation","text":"","category":"section"},{"location":"Models/","page":"Models","title":"Models","text":"The analysis of dose-response data with the models above essentially means the estimation of the density g(k) from the dose-response data. To simplify the inference problem, g(k) is approximated by a sum of constant functions over a disjunct set of intervals I_j_j=1^m:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"g(k) approx sum_j=1^m g_j cdot chi_I_j(x) qquad textwith qquad chi_I_j(x) = left beginarrayll 1    x in I_j 0   textelse endarray right","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"With this approximation, the accumulation model becomes:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"x(a) approx sum_j=1^m g_j int_I_j(1-e^-fracak) dk ","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Thus, the inference problem is the estimation of the parameters g_1ldots g_m.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"The intervals I_j and the weights g_j are implemented as one-dimensional grid with the AdaptiveDensityApproximation package.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"using AntibodyMethodsDoseResponseConvenience #hide\nusing AdaptiveDensityApproximation\ngrid = create_grid([1,2,3,5])","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"The example above created a grid corresponding to the intervals 122335 with weights g_j = 1.  To view the grid properties, the AdaptiveDensityApproximationRecipes package can be used:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"using AdaptiveDensityApproximationRecipes, Plots\nplot(grid)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"New weights can be set with import_weights!:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"import_weights!(grid, [1,2,0.5])\nplot(grid)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"When the intervals have different lengths, the overall impact of the weights g_j becomes skewed, since the term int_I_j(1-e^-fracak) dk depends on the interval length. For the estimation of parameters it can be beneficial to use length-normalized parameters:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"g_j = fraclambda_jtextlength(I_j)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"In other words, while g_j is the density value, lambda_j is the number of epitopes with K_tauin I_j.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Finally, the analytical solution of int_I_j(1-e^-fracak) dk requires the exponential integral function, not implemented in Julia Base. To avoid additional dependencies, this integral is approximated by","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"int_I_j(1-e^-fracak) dk approx textlength(I_j) cdot (1-e^-fracatextcenter(I_j))","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Rightarrow quad x(a) approx sum_j=1^m g_j int_I_j(1-e^-fracak) dk approx sum_j=1^m g_j cdot textlength(I_j) cdot (1-e^-fracatextcenter(I_j)) = sum_j=1^m lambda_j cdot (1-e^-fracatextcenter(I_j))","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"info: Weights of the grid\nBecause of the above model, the weights of OneDimGrid objects are always treated as lambda_j throughout this package. Thus, they describe the number of epitopes with K_tau in the given interval, not the K_tau-density value!","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"remark: Inverse constant\nTo solve the problem of integrability, the inverse constant widetildeK = frac1K_tau can be used: int (1-e^-acdot widetildek)  d widetildek = frace^-acdot widetildeka + widetildek + textconstant While the use of the inverse constant does not change the discrete superposition (countable sum), the integral approximation uses a different  density widetildeg if the inverse constant is used.","category":"page"},{"location":"Models/#Obtain-model-functions","page":"Models","title":"Obtain model functions","text":"","category":"section"},{"location":"Models/","page":"Models","title":"Models","text":"Having specified the intervals with a grid, the model function can be obtained with the following model generators: accumulation_model, langmuir_model, accumulation_inv_const_model and langmuir_inv_const_model.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"model, init_params, centers, volumes = accumulation_model(grid, offset = 10) \nnothing #hide","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"model is a ModelFunctions object from the FittingObjectiveFunctions package, containing both the model function and the partial derivatives w.r.t. to the parameters.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"init_params contains the weights of the grid, and as last element the offset if offset != nothing:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"println(init_params)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"centers contains the center points of the intervals of the grid:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"println(centers)","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"and volumes contains the lengths of the intervals of the grid:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"println(volumes)","category":"page"},{"location":"Models/#Tips-for-girds","page":"Models","title":"Tips for girds","text":"","category":"section"},{"location":"Models/","page":"Models","title":"Models","text":"Choosing unequal interval sizes in the example above was not just for demonstration purposes. In fact, a rule of thumb for the K_tau range is to use the concentration/dilution range of the dose-response curve, which often spans multiple orders of magnitude. Consider for example the range 10^-810^-2:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"plot(create_grid(LinRange(1e-8,1e-2,50)))","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"In a linear scale, this interval discretization seems to resolve the range well enough. But plotting the same grid in a logarithmic scale leads to:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"plot(create_grid(LinRange(1e-8,1e-2,50)), xaxis = :log, xticks = [10.0^-i for i in 2:8])","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Equally sized intervals poorly resolve the smaller orders of magnitude. A single interval covers the range 10^-810^-4, while almost all intervals subdivide the range 10^-310^-2. A solution for this problem is to use logarithmically sized intervals:","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"plot(create_grid(LogRange(1e-8,1e-2,50)), xaxis = :log, xticks = [10.0^-i for i in 2:8])","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"tip: LogRange\nJulia provides the LinRange function to create equally spaced points in a given range. This package adds LogRange to create logarithmically spaced points in a given range, following the same syntax: LinRange(start, stop, n_points, [base = 10]).","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"Inspecting the logarithmic grid in a linear scale shows that the intervals still resolve the larger orders of magnitude of the range reasonably well.","category":"page"},{"location":"Models/","page":"Models","title":"Models","text":"plot(create_grid(LogRange(1e-8,1e-2,50)))","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/#Background:-Logarithmic-posterior-probability","page":"Background","title":"Background: Logarithmic posterior probability","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"The general setting is the same as in Background:-Posterior-probability. The starting point is","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"p(lambda mid x_i_i=1^N y_i_i=1^N m) propto  p_0(lambdamid x_i_i=1^N m) prod_i_1^n ell_i(y_imid lambda x_im) ","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"assuming the likelihoods ell_i are known.","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/#Product-of-small-numbers","page":"Background","title":"Product of small numbers","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"In the formula for the posterior likelihood, it can happen that many small numbers (close to zero) need to be multiplied together. Because floating point numbers can only represent numbers up to a certain precision, such products, though theoretically non-zero, tend to be rounded to zero.","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"For example, consider the following array as the likelihood values:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"using Distributions, BenchmarkTools\nsmall_values = [pdf(Normal(0,1),10+i) for i in 1:10]","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"Although the values are non-zero, the product is rounded to zero:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"prod(small_values)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"One could use floating point types with higher precision:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"small_values_high_precision = BigFloat.(small_values)\nprod(small_values_high_precision)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"However, this entails a huge performance loss together with increased memory usage: ","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"@benchmark prod(small_values)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"@benchmark prod(small_values_high_precision)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/#Logarithmic-scale","page":"Background","title":"Logarithmic scale","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"Since posterior probabilities are often unnormalized anyways, one is not interested in the particular values, but only in relative differences. But then, any strictly monotonic function can be applied to compare relative differences. A convenient choice for such a strictly monotonic (increasing) function is the logarithm.","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"Note that because of proportionality, there is a constant alpha  0 such that","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"p(lambda mid x_i_i=1^N y_i_i=1^N m) =  alpha cdot  p_0(lambdamid x_i_i=1^N m) prod_i_1^n ell_i(y_imid lambda x_im) ","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"Applying the natural logarithm leads to:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"beginaligned\nln (p(lambda mid x_i_i=1^N y_i_i=1^N m)) =  ln left(alpha cdot  p_0(lambdamid x_i_i=1^N m) prod_i_1^n ell_i(y_imid lambda x_im) right)  \n= ln(p_0(lambdamid x_i_i=1^N m)) + sum_i=1^N ln(ell_i(y_imid lambda x_im)) + ln(alpha)\nendaligned","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"Using the logarithm allowed to exchange the multiplication of small numbers for an addition in the logarithmic scale, at the cost of having to calculate the logarithm of every value. However, the cost of calculating the logarithm is the worst case scenario. In many cases, it is possible if not easier to implement logarithms of the involved densities (e.g. for the normal distribution, laplace distribution, etc.).","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"To shorten the notation, denote the logarithms of the distributions by L_p = ln circ p for the posterior, L_i= ln circ ell_i for the likelihoods and L_0 =ln circ p_0 for the prior: ","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"L_p(lambda mid x_i_i=1^N y_i_i=1^N m) =   L_0(lambdamid x_i_i=1^N m) +  sum_i_1^n L_i(y_imid lambda x_im) + textconst","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/#Effect-of-Logarithmic-scale","page":"Background","title":"Effect of Logarithmic scale","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"Using the logarithm has two effects. First of all, the product becomes a sum. This alone would suffice to prevent the rounding to zero problem:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"sum(small_values)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"In addition, the logarithm has the effect of compressing the number scale for numbers larger than 1 and to stretch out the number scale for numbers between 0 and 1:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"log_values = log.(small_values)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"Of course, the sum is still non-zero:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"sum(log_values)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"While the use of higher precision floating point numbers (BigFloat) meant a huge performance loss, the log scale method dose not impair performance:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"@benchmark sum(log_values)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/#Logarithmic-density-example","page":"Background","title":"Logarithmic density example","text":"","category":"section"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"In Logarithmic-scale it was mentioned that some distributions are even easier to be implemented in a logarithmic scale. This is not only the case for the definition of densities from scratch, but also applies for Distributions.jl. Observe that \"far\" away from the mean, the pdf of a normal distribution is rounded to zero:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"pdf(Normal(0,1),100)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"Obviously, the logarithm cannot be applied to this. However, Distributions.jl offers a logpdf function:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"logpdf(Normal(0,1),100)","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"This allows values even further away from the mean:","category":"page"},{"location":"FittingObjectiveFunctions/log_posterior_background/","page":"Background","title":"Background","text":"logpdf(Normal(0,1),10^20)","category":"page"},{"location":"MeasurementData/#Measurement-data","page":"Measurement data","title":"Measurement data","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To work with measurement data, it needs to be stored in a FittingData object from the FittingObjectiveFunctions package.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"using FittingObjectiveFunctions\nfitting_data = FittingData(concentrations, mean_responses, uncertainties)","category":"page"},{"location":"MeasurementData/#Check-data","page":"Measurement data","title":"Check data","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Good dose-response data must satisfy the following properties:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The concentrations and the responses must be positive.\nAll values must be real numbers.\nNo NaN or Inf.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"These properties can be checked, using dose_response_check:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"using AntibodyMethodsDoseResponseConvenience #hide\nnothing #hide","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"dose_response_check(FittingData([1,2],[-1,2]))","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"If dose_response_check does not throw an error, the FittingData object contains proper dose-response data.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"info: Info\ndose_response_check is used internally by some functions to ensure proper data transformation. E.g. data normalization or depletion corrections require proper dose-response data.","category":"page"},{"location":"MeasurementData/#Normalize-data","page":"Measurement data","title":"Normalize data","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Dose-response curves from different sources may require normalization. For example, replicates from different experiments could have used different exposure times. There are two methods to normalize the data. The first method requires a reference signal (scanned during the experiments) to which the other responses can be normalized to. The second method normalizes the dose-response curve s.t. the strongest response is 1.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To normalize the data to 1 use the normalize_data function without additional keywords.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"data = FittingData([1,2,3],[1,2,3])\nnormalize_data(data)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To normalize the data to a reference signal, i.e. 2, the reference keyword can be used:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"normalize_data(data, reference = 2)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Another common normalization step is the removal of a constant offset, caused e.g. by autofluorescence. Since both offset removal and reference scaling are applied, it is important to understand the order of the corrections:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The offset is subtracted from all response values\nIf the reference keyword is used, the offset is also subtracted from the reference value. This is, because reference measurements often suffer from the same offset.\nThe responses are rescaled\t\nIf the reference keyword was used, all responses are divided by the modified reference value.\nOtherwise, the responses are rescaled, s.t. the largest response is 1.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"In the following example, 0.5 is subtracted from the response values [1,2,3]->[0.5,1.5,2.5]. Then the responses are divided by the largest response 2.5 to rescale the responses:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"normalize_data(data, offset = 0.5)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"info: Measurement errors\nThe measurement errors are also normalized, following standard Gaussian error propagation (reference and offset are without errors). Thus, the measurement errors are just rescaled.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Without the reference keyword, it is possible to have the offset value be determined automatically, i.e. the dose-response curve is shifted s.t. the smallest response is zero:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"normalize_data(data, offset = Inf)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Internally, any offset that is too large is replaced by the smallest response value. When the reference keyword is used, it is not recommended to use arbitrary offsets, as they are subtracted from the reference value, too. Furthermore, offset values that are larger than the reference value (after being replaced by the smallest response) throw an error:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"normalize_data(data, offset = 2, reference = 0.1)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"tip: Mutation of data\nnormalize_data does not mutate the original FittingData object, but returns a normalized copy. To mutate the original object, use normalize_data!.","category":"page"},{"location":"MeasurementData/#Simple-depletion-correction","page":"Measurement data","title":"Simple depletion correction","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To keep the models computationally simple, e.g. by using analytical solutions, antibody depletion is not accounted for. Yet, depending on the experimental protocol, depletion can be unavoidable. Fortunately, there is simple approximation to obtain new fixed concentrations that define lower bounds for the real binding process that is subject to depletion:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Let (a_ir_i) denote the initial antibody concentrations a_i and the corresponding responses r_i. Then lower-bound concentrations are ","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"b_i = a_i - widehatbeta r_i qquad textwhere qquad widehatbeta = max beta in mathbbR_0 mid a_i -beta r_i geq 0  forall i","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"This approximation holds true both for the accumulation model as well as the Langmuir isotherm model, albeit for different reasons. The maximization of the parameter widehatbeta is due to the usually unknown proportionality factor between the response signal and the actual number of bound complexes.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To obtain this \"scale bound\" widehatbeta the scale_bound function can be used:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"β = scale_bound(FittingData([1,2,3],[1,1.5,1.9]))","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"To obtain the lower-bound concentrations b_i, the simple_depletion_correction function can be used:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"simple_depletion_correction(FittingData([1,2,3],[1,1.5,1.9]), β)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Note that a new FittingData object is returned, containing the lower-bound concentrations b_i instead of the initial concentrations a_i. It is possible to use different scales for simple_depletion_correction. But for the scale_bound there is a shortcut (which internally calls scale_bound):","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"simple_depletion_correction(FittingData([1,2,3],[1,1.5,1.9]))","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"tip: Mutation of data\nAgain, simple_depletion_correction does not mutate the original FittingData object, but returns a corrected copy. To mutate the original object, use simple_depletion_correction!.","category":"page"},{"location":"MeasurementData/#measurement_data_plotting","page":"Measurement data","title":"Plotting","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Of course, FittingData objects can be plotted with any plotting library by calling the fields:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"using Plots\ndata = FittingData([0,1,2,3,4],[0,1,1.5,1.9,2.1])\nplot(data.independent, data.dependent, yerrors = data.errors)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"For convenience, the AntibodyMethodsDoseResponseRecipes packaged contains plotting recipes (Plots.jl) for FittingData objects:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"using Plots, AntibodyMethodsDoseResponseRecipes\ndata = FittingData([0,1,2,3,4],[0,1,1.5,1.9,2.1])\nplot(data)","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Observe that the data point with concentration = 0 is missing. Since dose-response curves are commonly plotted in a logarithmic scale and since Plots.jl does not automatically remove zero values from logarithmic plots (which become -infty), the plotting recipe introduces the keyword filter_zeros = [true,false]. The filter_zeros keyword expects two Bool values. If the first value is true, all data points with concentration = 0 are removed from the plot. Accordingly, if the second value is true, all data points with response = 0 are removed from the plot.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The plotting recipe defines how Plots.jl handles the data inside a FittingData object. Thus, the usual keywords remain usable and can be combined with the filter_zeros keyword:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"plot(data, color = :red, filter_zeros = [false,false])","category":"page"},{"location":"MeasurementData/#[FittingData](@ref)-and-[FittingCondition](@ref)","page":"Measurement data","title":"FittingData and FittingCondition","text":"","category":"section"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Internally FittingCondition objects expect measurement data to be stored in FittingData objects. Yet, the quick start guide mentions FittingData objects only as optional method to implement specific measurement errors. This is, because FittingCondition offers additional constructors, some of which automatically create the FittingData objects.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The default constructor uses FittingData objects:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"data = FittingData([1,2,3],[1,1.5,1.9], [0.4,0.4,0.4], distributions = (y,m,Δy)-> -abs(y-m))\ncondition = FittingCondition(data)\ncondition.data ","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Using the FittingData constructor allows to specify different measurement errors, as mentioned in the tip, but also different uncertainty distributions for posterior based objectives.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"The convenience constructor bypasses the need to construct the FittingData explicitly, expecting only the concentrations and the responses:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"condition = FittingCondition([1,2,3],[1,1.5,1.9])\ncondition.data ","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Note that the measurement errors are set to 1.","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"Finally, the convenience constructor allows to pass multiple response arrays:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"condition = FittingCondition([1,2,3],[1,1.5,1.9],[0.8,1.7,2.8])\ncondition.data ","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"If multiple response arrays are provided to the constructor, it calculates the mean values for the responses and uses the standard deviation for the measurement errors. In addition, it adds the individual responses as replicates:","category":"page"},{"location":"MeasurementData/","page":"Measurement data","title":"Measurement data","text":"condition.replicates ","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/#Posterior-probability:-How-to-implement","page":"How to implement","title":"Posterior probability: How to implement","text":"","category":"section"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"Consider the data and model from Simple-example:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"using FittingObjectiveFunctions, Plots #hide\n\nX = collect(1:10)\nY = [1.0, 1.78, 3.64, 3.72, 5.33, 2.73, 7.52, 9.19, 6.73, 8.95]\nΔY = [0.38, 0.86, 0.29, 0.45, 0.66, 2.46, 0.39, 0.45, 1.62, 1.54]\ndata = FittingData(X,Y,ΔY)\nmodel = ModelFunctions((x,λ)-> λ*x)\n\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/#Likelihood-functions","page":"How to implement","title":"Likelihood functions","text":"","category":"section"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"Observer that no distributions were specified in the constructor for data above. As explained in FittingData, the constructor then defaults to normal distributions.  The likelihood function that corresponds to the weighted least squares objective (see Retrieving the LSQ objective) can thus be obtained by","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"lsq_likelihood = posterior_objective(data,model)","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"Like lsq_objective, posterior_objective returns a function that takes the model parameters λ as argument.","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"Normal distributions are not the only possible y-uncertainty distributions (q_i(y_i mid m(x_ilambda))). For example, one might assume a heavy-tailed distribution for measurements, e.g. a Cauchy distribution:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"using Distributions #hide\nplot(x-> pdf(Normal(0,1),x), label = \"Normal(0,1)\") #hide\nplot!(x-> pdf(Cauchy(0,1),x), label = \"Cauchy(0,1)\") #hide","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"To modify the y-uncertainty distributions, the FittingData object must be redefined (see FittingData). The distributions must have the signature (y,m,Δy):","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"cauchy(y,m,Δy) = pdf(Cauchy(m,Δy),y)\ndata_cauchy = FittingData(X,Y,ΔY,distributions = cauchy)\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"Now a likelihood function with Cauchy uncertainty distributions can be created:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"cauchy_likelihood = posterior_objective(data_cauchy,model)","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"To compare the shape of the resulting likelihood functions, it is helpful to scale up the cauchy_likelihood, such that the maxima have the same height:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"large_scope = plot(lsq_likelihood, xlims = [0.9,1.2], label=\"lsq_likelihood\", legend = :topleft) #hide\nplot!(x-> 16 * cauchy_likelihood(x), label = \"cauchy_likelihood\") #hide\nsmall_scope =  plot(lsq_likelihood, xlims = [1.0725,1.0825], legend = :none) #hide\nplot!(x-> 16 * cauchy_likelihood(x)) #hide\nplot(large_scope,small_scope, layout = (1,2), size = (800,300))#hide","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"tip: More general distributions\nIt is possible to define a likelihood distribution for each data point. Furthermore, these functions can be general julia functions, i.e. while the input arguments must be (y,m,Δy), they need not be utilized in the function.For example, we can assign normal distributions with σ=1 for the first 5 data points, and Cauchy distributions width sigma_i = Delta y_i for the remaining data points:normal_dists = [(y,m,Δy)-> pdf(Normal(m,1),y) for i in 1:5]\ncauchy_dists = [(y,m,Δy)-> pdf(Cauchy(m,Δy),y) for i in 6:length(Y)]\ndata_example = FittingData(X,Y,ΔY, distributions = vcat(normal_dists...,cauchy_dists...))\nlikelihood = posterior_objective(data_example,model)One application for this flexibility is to use the marginalization formula for the likelihood form section Independent-data-points ","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/#Using-priors","page":"How to implement","title":"Using priors","text":"","category":"section"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"As described in the remark about the objectivity of priors, one always retrieves the likelihood function, when using a uniform prior (over the range of computer representable numbers). This is in fact what happened in the examples Likelihood-functions, as the full constructor for posterior objectives has an optional argument:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"posterior_objective(data::FittingData,model::ModelFunction,prior::Function= λ -> 1)","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"This means, whenever only the two arguments data and model are used, the last argument defaults to λ-> 1. To specify a certain prior, one just needs to pass it as third argument. ","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"For example, the theory and/or other measurements could indicate that the true parameter value should be lambda = 1. To implement a normal distribution with mu =1 and sigma = 01 as prior, the third argument must be the pdf function for said normal distribution (here using the build in pdf function from Distributions.jl):","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"posterior = posterior_objective(data,model,λ-> pdf(Normal(1,0.1),λ))","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"Again, since the posterior and the likelihood are not properly normalized, rescaling is necessary to compare the shapes of lsq_likelihood and posterior:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_implementation/","page":"How to implement","title":"How to implement","text":"large_scope = plot(x-> 10/3.3*lsq_likelihood(x), xlims = [0.9,1.2], label = \"lsq_likelihood\", legend = :topleft) #hide\nplot!(posterior, label = \"posterior\")  #hide\nsmall_scope = plot(x-> 10/3.3*lsq_likelihood(x), xlims = [1.065,1.085], legend = :none) #hide\nplot!(posterior)  #hide\nplot(large_scope,small_scope, layout = (1,2), size = (800,300)) #hide","category":"page"},{"location":"FittingObjectiveFunctions/#FittingObjectiveFunctions","page":"Introduction","title":"FittingObjectiveFunctions","text":"","category":"section"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"This is a lightweight package without dependencies to create objective functions for model-fitting. To avoid dependencies, this package does not include optimizers / samplers.","category":"page"},{"location":"FittingObjectiveFunctions/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"This package is not in the general registry and needs to be installed from the GitHub repository:","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/AntibodyPackages/FittingObjectiveFunctions\")","category":"page"},{"location":"FittingObjectiveFunctions/#Simple-example","page":"Introduction","title":"Simple example","text":"","category":"section"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"After the installation, the package can be used like any other package:","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"using FittingObjectiveFunctions","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"Consider the following example data-set:","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"using Plots\n\nX = collect(1:10)\nY = [1.0, 1.78, 3.64, 3.72, 5.33, 2.73, 7.52, 9.19, 6.73, 8.95]\nΔY = [0.38, 0.86, 0.29, 0.45, 0.66, 2.46, 0.39, 0.45, 1.62, 1.54]\n\nscatter(X,Y, yerror = ΔY, legend=:none, xlabel = \"X\", ylabel=\"Y\")","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"Before objective functions can be created, the data needs to be summarized in a FittingData object:","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"data = FittingData(X,Y,ΔY)\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"Information about the model needs to be summarized in a ModelFunctions object. Here we choose a simple linear model m(xlambda) = lambda x:","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"model = ModelFunctions((x,λ) -> λ*x) \nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"A weighted least squares objective can be be constructed as follows:","category":"page"},{"location":"FittingObjectiveFunctions/","page":"Introduction","title":"Introduction","text":"lsq = lsq_objective(data,model)\n\nplot(λ-> lsq(λ), legend = :none, xlabel = \"λ\", ylabel = \"lsq\")","category":"page"},{"location":"ResultsAndSimulations/#Results-and-Simulations","page":"Results and simulations","title":"Results and Simulations","text":"","category":"section"},{"location":"ResultsAndSimulations/#Why-OneDimGrid-objects?","page":"Results and simulations","title":"Why OneDimGrid objects?","text":"","category":"section"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"The model generator requires a OneDimGrid objects from the AdaptiveDensityApproximation package (see Models). For this, the actual weights of the grid do not matter. The model generator returns a new parameter array with the goal to estimate these parameters. At this point it is also possible to choose parameter values for this array and to simulate dose-response curves with the corresponding model function.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"But the AdaptiveDensityApproximation offers additional methods, e.g. the name-giving adaptive approximation of densities or additional density conversion / analysis tools. For this reason, internal methods use OneDimGrid objects and construct the model functions from scratch for the calculation of dose-response curves. This is, among others, the reason why most functions (e.g. the convenience functions of AntibodyMethodsDoseResponseConvenience) return or expect those grids. ","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"tip: Tip\nAlthough not necessary for all analyses, it is highly recommended to use the OneDimGrid workflow, as advanced methods of this package will expect grids.","category":"page"},{"location":"ResultsAndSimulations/#Simulating-the-K_\\tau-density","page":"Results and simulations","title":"Simulating the K_tau-density","text":"","category":"section"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"To simulate a dose-response curve with a binding model, a density g(K_tau) needs to be defined. This can be done with any Julia function, e.g. a probability density function:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"using AntibodyMethodsDoseResponseConvenience\nusing Distributions\n\np(x) = pdf(Normal(1e-5,3e-6),x)\nplot(p, xaxis = :log, xlims = [1e-10,1e-2], fill = 0, label = \"density\")","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"The plot function can be used without importing Plots.jl, as AntibodyMethodsDoseResponseConvenience does this in the background automatically.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"Next, a OndDimGrid needs to be defined to approximate the density with:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"grid = create_grid(LogRange(1e-10,1e-2,50))\napproximate_density!(grid, p, volume_normalization = true)","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"info: volume_normalization = true\nWithout volume_normalization = true (the default), the density function itself is approximated (e.g. by using the function values at the centers of the respective intervals). The volume normalization approximates the area under the curve by using function value × interval length. This is a convenient choice for simulations, as the area under a density curve corresponds to the number of epitopes in the given interval, which is exactly what the weights of the grid should be.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"To inspect the grid, the plotting recipe from the AdaptiveDensityApproximationRecipes package can be used (as already described in Models):","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"using AdaptiveDensityApproximationRecipes\nplot(grid, xaxis = :log)","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"info: y-axis scale\nSince the grid approximates the area under the density curve (weights correspond to the height of the bars), the scale of the y-axis is different, compared to the density plot.","category":"page"},{"location":"ResultsAndSimulations/#Simulating-the-dose-response-curve","page":"Results and simulations","title":"Simulating the dose-response curve","text":"","category":"section"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"With the OneDimeGrid object grid, a dose-response can be simulated, using DoseResponseResult:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"concentrations = LogRange(1e-8,1e-2,16)\nsimulation_result = DoseResponseResult(grid,concentrations; model = accumulation_model, offset = 0)\nscatter(simulation_result, xaxis = :log)","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"info: DoseResponseResult\nDoseResponseResult objects are used to construct and store dose-response curves, resulting from grids. This can be either because a grid was used to simulate a K_tau-density or because the result of a model-fit was stored in a grid. The package AntibodyMethodsDoseResponseRecipes provides a plotting recipe for DoseResponseResult objects.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"tip: filter_zeros\nThe same filter_zeros keyword that is used for FittingData plots can also be used for DoseResponseResult plots (see Measurement Data plotting).","category":"page"},{"location":"ResultsAndSimulations/#Importing-fitting-results","page":"Results and simulations","title":"Importing fitting results","text":"","category":"section"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"Instead of simulating a dose-response curve, the OneDimGrid and DoseResponseResult types can also be used to create dose-response curves from a fitting result. Since no data has been fitted yet, we construct a result from the weights of the simulation grid above:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"parameters = export_weights(grid)\npush!(parameters, 0.2) # Add offset parameter","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"We assume now, that the gird was used to obtain the model function and that the parameters are the result of the model fit. In this case, the offset keyword was used. To import the result into the grid, the import_weights! functions can be used:","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"import_weights!(grid, parameters[1:end-1])","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"info: Why end-1 ?\nSince the offset keyword was used for the creation of model functions (in our scenario), the parameters array has one additional element at the end, the offset, which does not belong to the grid. If no offset is used, all parameters should be imported:import_weights!(grid, parameters)In fact, using the wrong selection of parameters usually leads to a DimensionMismatch error, as the number of parameters and the number of intervals in the grid do not match.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"import_weights!(grid, parameters) # Wrong parameter selection should fail.","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"After importing the parameters into the grid, the dose-response curve can be constructed as before (for any concentrations, not only the data concentrations):","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"concentrations = LogRange(1e-8,1e-2,16)\nresult = DoseResponseResult(grid,concentrations; model = accumulation_model, offset = parameters[end])\nscatter(result, xaxis = :log, ylims = [0,1.4])","category":"page"},{"location":"ResultsAndSimulations/","page":"Results and simulations","title":"Results and simulations","text":"Observe the offset = parameters[end] part at the end of the DoseResponseResult call. In our scenario, the parameters array contains the offset as last element.","category":"page"},{"location":"API_Convenience/#api_convenience","page":"AntibodyMethodsDoseResponseConvenience","title":"API - Convenience package","text":"","category":"section"},{"location":"API_Convenience/#Fitting-data","page":"AntibodyMethodsDoseResponseConvenience","title":"Fitting data","text":"","category":"section"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"scaled_log_volume_prior","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.scaled_log_volume_prior","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.scaled_log_volume_prior","text":"scaled_log_volume_prior(scale::Real = 1)\n\nCreate a prior generator (see AdaptiveOptions) that generates the following prior:\n\ntextprior(lambda) = - fractextscaletextlength(λ)^2 cdot left( textoffset^2 + sum_i=2^textlength(lambda) left(fraclambda_i-1log(r_i-1)-log(l_i-1) - fraclambda_ilog(r_i)-log(l_i)right)^2 right)\n\nwhere l_ir_i are the intervals corresponding to lambda_i, calculated from centers and volumes.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"minimizer_generator","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.minimizer_generator","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.minimizer_generator","text":"minimizer_generator(optim_minimizer; options = Optim.Options(g_tol = 1e-12, iterations = 2000), gradient::Bool = false)\n\nCreate minimization function (f,∇f,initial_point) -> minimizing_point as specified in adaptive_dose_response_fit, using minimizers from Optim.jl (e.g. NelderMead() or LBFGS()).\n\nIf gradient = false, the gradient function ∇f is ignored, useful e.g. for adaptive_dose_response_fit where ∇f = nothing is passed in some cases.\n\nExamples\n\nminimizer_generator(NelderMead())\nminimizer_generator(LBFGS(), options = Optim.Options(g_tol = 1e-6, iterations = 400), gradient = true)\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"FittingCondition","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.FittingCondition","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.FittingCondition","text":"mutable struct FittingCondition\n\nData type storing the necessary information for the common workflow of adaptive_dose_response_fit. Convenience constructors with recommended options are implemented. Note that all objects are \"deepcopied\" to avoid unwanted mutation.\n\nFields\n\ndata: The FittingData object containing the dose-response data.\nreplicates: Vector of FittingData objects that constitute the replicates of measured dose-response curves.\ngrid: Initial K_τ grid that is adaptively refined.\npath: Fitting results are saved to path if path != \"\".\noptions_1: AdaptiveOptions for the first run of adaptive_dose_response_fit.\noptions_2: AdaptiveOptions for a second run of adaptive_dose_response_fit, e.g. to use a final, non-adaptive, gradient-based fit.\nminimizer_1: Minimization function for the first run of adaptive_dose_response_fit.\nminimizer_2: Minimization function for the second run of adaptive_dose_response_fit.\nresult_concentrations: Concentrations to be used for the dose-response curve calculated from the fit result. This allows to obtain smooth result curves. If result_concentrations = nothing, the concentrations of data are used.\n\nConvenience constructors\n\nFittingCondition(data::FittingData, replicates = nothing; keywords...)\n\nManual specification of the FittingData object and the optional replicates. Recommended fitting options are predefined and path=\"\" is set to avoid accidental creation of files. The keywords are equivalent to the fields.\n\nFittingCondition(concentrations::AbstractVector, response_replicates::AbstractVector...; keywords...)\n\nConstruct a FittingCondition from a concentration vector and response vectors (variable number of arguments). This automatically creates the main FittingData object, and the vector of FittingData objects for the replicates.\n\nThe main FittingData object uses the mean values of the responses together with the standard deviations as uncertainties. The uncertainty distributions are unnormalized logarithmic normal distributions:\n\n(y,m,Δy)-> -(y-m)^2/Δy^2\n\nKeywords\n\nThe keywords correspond to the struct fields, except for the additional scale keyword. Setting scale overwrites the objective field to :log_posterior and the prior_generator field to scaled_log_volume_prior for both options: options_1 and options_2.\n\nThe keyword defaults are:\n\ngrid = create_grid(LogRange(extrema(concentrations)...,3))\npath = \"\"\noptions_1 = AdaptiveOptions(objective = :lsq, offset = eps(), iterations = 30)\noptions_2 = AdaptiveOptions(objective = :lsq, offset = eps())\nminimizer_1 = minimizer_generator(NelderMead())\nminimizer_2 = minimizer_generator(LBFGS())\nresult_concentrations = nothing\nscale = nothing\n\n\n\n\n\n","category":"type"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"fit_condition","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_condition","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.fit_condition","text":"fit_condition(condition::FittingCondition)\n\nObtain the results for a FittingCondition object (i.e. fitting the data).\n\nReturns the AdaptiveResult object and saves the data (FittingCondition and AdaptiveResults objects) to FittingCondition.path if not FittingCondition.path = \"\".\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"fit_conditions","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_conditions","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.fit_conditions","text":"fit_conditions(conditions)\n\nMultithreaded application of fit_condition to a collection of FittingCondition objects (conditions).\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/#Loading-data","page":"AntibodyMethodsDoseResponseConvenience","title":"Loading data","text":"","category":"section"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"load_results","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.load_results","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.load_results","text":"load_results(path::AbstractString)\n\nLoad results and data as saved by fit_condition. Returns (result, data,replicates) as AdaptiveResult, FittingData and vector of FittingData objects.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/#Modify-default-plotting-options","page":"AntibodyMethodsDoseResponseConvenience","title":"Modify default plotting options","text":"","category":"section"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"info: Info\nIn the plotting functions, the default options are not set up as tuples of keyword arguments, but instead as function calls. The following functions generate the default keyword arguments, but allow to selectively change individual keywords or pass new Plots.jl keywords. In this way, changing the keywords does not require to manually repeat the unchanged default keyword arguments.","category":"page"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"dr_base_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.dr_base_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.dr_base_plot","text":"function dr_base_plot(keywords...)\n\nFunction to return a modified dose-response base plot. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nxaxis = :log\nxlabel = \"dilution\"\nylabel = \"response\"\nlegend = :topleft\ndensity = 300\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"density_base_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.density_base_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.density_base_plot","text":"density_base_plot(keywords...)\n\nFunction to return a modified K_τ density base plot. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nxaxis = :log\nxlabel = \"K_τ\"\nylabel = \"density\"\nlegend = :topleft\ndensity = 300\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"data_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.data_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.data_options","text":"data_options(keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the FittingData object. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nseriestype = :scatter\ncolor = 1\nlabel = \"mean values\"\nyerrors = nothing\n\nIn addition, the following keyword ia available:\n\nfilter_zeros = [true,false]: Select to omit data points from the plot when the x-value is zero (if true for first element of filter_zeros) or the y-value is zero (if true for second element of filter_zeros) See Measurement data - Plotting) for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"replicate_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.replicate_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.replicate_options","text":"replicate_options(keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the replicate data. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nseriestype = :scatter\ncolor = :black\nopacity = 0.2\nlabel = \"replicates\"\nyerrors = nothing\n\nIn addition, the following keyword ia available:\n\nfilter_zeros = [true,false]: Select to omit data points from the plot when the x-value is zero (if true for first element of filter_zeros) or the y-value is zero (if true for second element of filter_zeros) See Measurement data - Plotting) for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"fit_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.fit_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.fit_options","text":"fit_options(keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the DoseResponseResult response curve. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nseriestype = :path\ncolor = 2\nlabel = \"fit result\"\n\nIn addition, the following keyword ia available:\n\nfilter_zeros = [true,false]: Select to omit data points from the plot when the x-value is zero (if true for first element of filter_zeros) or the y-value is zero (if true for second element of filter_zeros) See Measurement data - Plotting) for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"density_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.density_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.density_options","text":"density_options(keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the DoseResponseResult density. Most Plots.jl keywords are available. By default, the following keyword arguments are set:\n\nseriestype = :path\ncolor = 2\nfillalpha = 0.5\nlabel = \"fitted density\"\n\nIn addition, the following keyword ia available:\n\nvolume_normalization = :log: Normalizes the grid weights for plotting. If :none the weights are not normalized, if :linear the weights are divided by their corresponding interval length and if :log the weights are divided by the interval length as it appears in a logarithmic plot. See Background: log-volume normalization for further explanation.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"eu_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.eu_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.eu_options","text":"eu_options(n::Integer, bins = nothing; keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the EpitopeUncertainty data series. \n\nn must be the number of levels (or larger) for the EpitopeUncertainty object that is plotted. If not bins = nothing the passed bins are marked in the plot with dashed lines (the color can be changed with the keyword bin_color). The bins must specify the indices of the gird intervals, e.g. [[1,2,3],[4,5], [9,10,11]]. The function select_indices can be used to obtain grid indices from grid domain ranges.\n\nMost Plots.jl keywords are available. In addition, the following keyword arguments are available:\n\ncolors = colormap(\"RdBu\",n)[end:-1:1] An array of colors (that Plots.jl accepts for the color keyword) corresponding to the different uncertainty levels. If the array contains less colors than uncertainty levels, the last color is repeated for the remaining levels.\nopacities = [1]: Array of opacities (number between 0 and 1) that correspond to the different uncertainty levels. Again, the last opacity is repeated if there are more uncertainty levels than opacities.\nreverse = false: If true the plotting order of the uncertainty levels is reversed. Since the uncertainty ranges are plotted on top of each other, this can become necessary when the EpitopeUncertainty constructor for samples is used, where larger levels correspond to larger uncertainty (as opposed to the bin-wise shifting constructor). \nvolume_normalization = :log: Normalizes the grid weights for plotting. If :none the weights are not normalized, if :linear the weights are divided by their corresponding interval length and if :log the weights are divided by the interval length as it appears in a logarithmic plot. See Background: log-volume normalization for further explanation.\nhide_labels = true: If true the labels are omitted. Can become necessary when a large number of uncertainty levels is used.\nbins = nothing: Specifies the positions for the bin-markers (dashed lines). The bins must specify the interval indices, e.g. [[1,2,3], [5,6]]. Ideally, the bins used for the EpitopeUncertainty construction should be used. If bins = nothing, bin markers are omitted.\nbin_color = :gray: Color of the bin markers.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"du_options","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.du_options","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.du_options","text":"du_options(n::Integer; keywords...)\n\nFunction to return a modified tuple of plotting keyword arguments for the EpitopeUncertainty data series. \n\nn must be the number of levels (or larger) for the EpitopeUncertainty object that is plotted. \n\nMost Plots.jl keywords are available. In addition, the following keyword arguments are available:\n\ncolors = colormap(\"RdBu\",n)[end:-1:1] An array of colors (that Plots.jl accepts for the color keyword) corresponding to the different uncertainty levels. If the array contains less colors than uncertainty levels, the last color is repeated for the remaining levels.\nopacities = [1]: Array of opacities (number between 0 and 1) that correspond to the different uncertainty levels. Again, the last opacity is repeated if there are more uncertainty levels than opacities.\nreverse = false: If true the plotting order of the uncertainty levels is reversed. Since the uncertainty ranges are plotted on top of each other, this can become necessary when the EpitopeUncertainty constructor for samples is used, where larger levels correspond to larger uncertainty (as opposed to the bin-wise shifting constructor). \nhide_labels = true: If true the labels are omitted. Can become necessary when a large number of uncertainty levels is used.\nfilter_zeros = [true,false]: Select to omit data points from the plot when the x-value is zero (if true for first element of filter_zeros) or the y-value is zero (if true for second element of filter_zeros) See Measurement data - Plotting) for further information.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/#Plotting-functions","page":"AntibodyMethodsDoseResponseConvenience","title":"Plotting functions","text":"","category":"section"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"bin_analysis_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.bin_analysis_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.bin_analysis_plot","text":"bin_analysis_plot(results::Union{AdaptiveResult,Nothing},data = nothing,replicates = nothing; keywords...)\n\nCreate and return basic plots (dr_plot, density_plot) for the DoseResponseResult and the K_τ-density gird. \n\nIf results is an AdaptiveResult, both the fitted gird is plotted into the density plot and the corresponding, theoretical curve is plotted into the dose-response plot.\n\nIf data is a FittingData object the data points are plotted into the dose-response plot. Similarly, if replicates is an array of FittingData objects, the data points are plotted as replicates in the dose-response plot.\n\nKeywords\n\ndr_plot =dr_base_plot(): The base plot onto which the AdaptiveResult.result and the FittingData objects (data and replicates) are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \ndensity_plot =density_base_plot(): The base plot onto which the AdaptiveResult.grid is plotted. It can be any Plots.jl plot (e.g. another K_τ density plot).\nfit_arguments =fit_options(): Keyword argument tuple for the AdaptiveResult.result data-series.\ndata_arguments =data_options(): Keyword argument tuple for the FittingData data-series.\nreplicate_arguments =replicate_options(): Keyword argument tuple for the replicate data-series.\ndensity_arguments =density_options(): Keyword argument tuple for the AdaptiveResult.grid data-series.\nannotation_arguments = NamedTuple(): Keyword argument tuple for bin-annotations in the density plot.\n\nAnnotation bins\n\nAnnotation bins allow to annotate the density plot with the number of epitopes (in units of the density values) in the respective bin. The following keywords can be used for the annotation_arguments:\n\nannotation_bins = []: The bins as grid domain ranges, e.g. [[1e-10,1e-9], [1e-9,1e-8], [1e-5,1e-2]].\nannotation_size = 10: Size of the annotation font.\nannotation_offset = 0.05: Relative vertical offset for the annotation from the top of the plot. If a single number is provided, every other annotation is offsetted.  If a length-matched vector of numbers is provided, each annotation is individually offsetted accordingly.\nannotation_color = :black: Color of the annotations.\nhover_points = false: If true, adds scatter-points with tool-tips for the Plotly.jl backend.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"peak_analysis_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.peak_analysis_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.peak_analysis_plot","text":"peak_analysis_plot(results::AdaptiveResult,data = nothing; keywords...)\n\nCreate and return plots to analyze the effect of peaks in the K_τ density on the corresponding dose-response curve.\n\nReturns (individual_dr_plot, cumulative_dr_plot, density_plot), where\n\ndensity_plot Contains a plot of the K_τ-density with different colors for the different peaks (specified by the bins).\nindividual_dr_plot: Contains the individual dose-response curves (color matched) that originate from the different peaks alone.\ncumulative_dr_plot: Contains the cumulative dose-response curves, i.e. dose-responses include the response increases caused by peaks with smaller K_τ. Again the curves are color matched with the peaks.\n\nIf data is a FittingData object the data points are plotted in the cumulative_dr_plot.\n\nKeywords\n\nindividual_dr_plot =dr_base_plot(): The base plot onto which the individual dose-response curves are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \ncumulative_dr_plot =dr_base_plot(): The base plot onto which the cumulative dose-response curves are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \ndensity_plot =density_base_plot(): The base plot onto which the K_τ-peaks are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \nfit_arguments =fit_options(): Keyword argument tuple for the AdaptiveResult.result data-series. Both color and label get overwritten by the colors keyword and the peak number (automatically determined).\ndensity_arguments =density_options(): Keyword argument tuple for the AdaptiveResult.grid data-series. Both color and label get overwritten with colors keyword and the peak number (automatically determined).\nbins =peak_detection(results.grid, fill = false)[2]: The bins that define the K_τ-peaks as grid domain ranges, e.g. [[1e-10,1e-9], [1e-9,1e-8], [1e-5,1e-2]].\ncolors = collect(1:length(bins)): The colors for the different bins.\njoin_bins = true: If true, extends the bins if needed, s.t. there remains no gap between the bins.\n\n\n\n\n\n","category":"function"},{"location":"API_Convenience/","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience","text":"uncertainty_plot","category":"page"},{"location":"API_Convenience/#AntibodyMethodsDoseResponseConvenience.uncertainty_plot","page":"AntibodyMethodsDoseResponseConvenience","title":"AntibodyMethodsDoseResponseConvenience.uncertainty_plot","text":"uncertainty_plot(e_uncertainty::EpitopeUncertainty,d_uncertainty::DoseResponseUncertainty,grid::OneDimGrid; keywords...)\n\nCreate and return uncertainty visualizations (dr_uncertainty_plot, density_uncertainty_plot).\n\nThe estimated bounds of the DoseResponseUncertainty and EpitopeUncertainty are plotted as color-matched ribbons.\n\nKeywords\n\ndr_plot =dr_base_plot(): The base plot onto which the AdaptiveResult.result and uncertainty ribbons are plotted. It can be any Plots.jl plot (e.g. another dose-response plot). \ndensity_plot =density_base_plot(): The base plot onto which the AdaptiveResult.grid and uncertainty ribbons are plotted. It can be any Plots.jl plot (e.g. another K_τ density plot). \neu_arguments =eu_options(length(e_uncertainty.levels)): Keyword argument tuple for the EpitopeUncertainty data series.\ndu_arguments =du_options(length(d_uncertainty.levels)): Keyword argument tuple for the DoseResponseUncertainty data series.\n\n\n\n\n\n","category":"function"},{"location":"FittingObjectiveFunctions/API/#API","page":"FittingObjectiveFunctions","title":"API","text":"","category":"section"},{"location":"FittingObjectiveFunctions/API/#The-FittingData-type","page":"FittingObjectiveFunctions","title":"The FittingData type","text":"","category":"section"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"FittingData","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.FittingData","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.FittingData","text":"mutable struct FittingData\n\nData type for fitting data.\n\nThis struct is only a container to check consistency and is not performance relevant, hence the mutability.\n\nFields\n\nindependent: Array of data points of the independent variable. \ndependent: Array of data points of the dependent variable.\nerrors: Array of measurement errors of the dependent variable.\ndistributions: Distribution for the dependent variable uncertainty. Can be a function or an array of functions (one for each data point). \n\nElements with the same index belong together, i.e. define a measurement: \n\n(independent[i], dependent[i], errors[i], distributions[i])\n\nConstructors\n\nFittingData(X,Y)\nFittingData(X,Y,ΔY;distributions = normal_distribution)\n\nDistributions\n\nThe distributions must have the signature (y,m,Δy), where y is the dependent data point, m is the result of the model function, given the dependent data point and the parameter, and Δy is the error of the dependent data point. By default, a normal distribution is used:\n\n(y,m,Δy) -> exp(-(y-m)^2/(2*Δy^2))/(sqrt(2*pi) * Δy)\n\n\n\n\n\n","category":"type"},{"location":"FittingObjectiveFunctions/API/#The-ModelFunctions-type","page":"FittingObjectiveFunctions","title":"The ModelFunctions type","text":"","category":"section"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"ModelFunctions","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.ModelFunctions","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.ModelFunctions","text":"mutable struct ModelFunctions\n\nMutable type to collect model functions (and the respective partial derivatives) to construct objective functions from.\n\nThis struct is only a container to check consistency and is not performance relevant, hence the mutability.\n\nFields\n\nmodel: The model function. Must have the signature (x,λ), where x is an independent data point, and λ are the parameters (e.g. an array for multiple parameters).\npartials: Array of partial derivative functions (one for each direction). Must have the same signature (x,λ) as the model function.\n\nConstructor\n\nModelFunctions(model, partials = nothing)\n\nExamples\n\nModelFunctions((x,λ)-> λ*x)\t\n\nModelFunctions((x,λ)-> λ*x, partials = [(x,λ)-> x])\t\n\nModelFunctions((x,λ)-> λ[1]*x+λ[2], partials = [(x,λ)-> x, (x,λ)-> 1])\n\n\n\n\n\n","category":"type"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"consistency_check","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.consistency_check","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.consistency_check","text":"consistency_check(fitting_data::FittingData,model::ModelFunctions)\n\nTest fitting_data and model, e.g. after mutation. \n\n\n\n\n\nconsistency_check(fitting_data::FittingData,model::ModelFunctions,λ)\n\nTest if all functions can be evaluated with the parameter λ. Also, test fitting_data and model, e.g. after mutation. \n\n\n\n\n\n","category":"function"},{"location":"FittingObjectiveFunctions/API/#Least-squares-objective","page":"FittingObjectiveFunctions","title":"Least squares objective","text":"","category":"section"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"lsq_objective","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.lsq_objective","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.lsq_objective","text":"lsq_objective(data::FittingData,model::ModelFunctions)\n\nReturn the least squares objective function lsq(λ).\n\nAnalytical expression\n\nindependent data points x_i\ndependent data points y_i\nerrors Δy_i (defaulting to 1)\nmodel function m\n\ntextlsq(lambda) = sum_i=1^N frac(y_i - m(x_ilambda))^2Delta y_i^2\n\n\n\n\n\n","category":"function"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"lsq_partials","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.lsq_partials","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.lsq_partials","text":"lsq_partials(data::FittingData,model::ModelFunctions)\n\nReturn the partial derivatives w.r.t. the parameters [∂_1 ob(λ),…,∂_n ob(λ)] of the least squares objective function ob(λ).\n\nThe partial derivatives (∂_μ m)(x,λ) of the model function must be specified in the ModelFunctions object model.\n\nAnalytical expression\n\nindependent data points: x_i\ndependent data points: y_i\nerrors: Δy_i (defaulting to 1)\nmodel function: m\npartial derivatives of model function in λ: ∂_μ m\n\npartial_mu textlsq(lambda) = sum_i=1^N frac 2 cdot (m(x_ilambda) - y_i) cdot (partial_mu m)((x_ilambda)) Delta y_i^2\n\n\n\n\n\n","category":"function"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"lsq_gradient","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.lsq_gradient","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.lsq_gradient","text":"lsq_gradient(data::FittingData,model::ModelFunctions)\n\nReturn the gradient function grad!(gradient,λ) for the least squares objective function ob(λ). The gradient function grad! mutates (for performance) and returns the gradient. The elements of gradient do not matter, but the type and length must fit.\n\nThe partial derivatives (∂_μ m)(x,λ) of the model function must be specified in the ModelFunctions object model.\n\nAnalytical expression\n\nindependent data points: x_i\ndependent data points: y_i\nerrors: Δy_i (defaulting to 1)\nmodel function: m\npartial derivatives of model function in λ: ∂_μ m\n\nnabla textlsq(lambda) =  sum_mu  sum_i=1^N frac 2 cdot (m(x_ilambda) - y_i) cdot (partial_mu m)((x_ilambda)) Delta y_i^2  vece_mu\n\n\n\n\n\n","category":"function"},{"location":"FittingObjectiveFunctions/API/#Posterior-objective","page":"FittingObjectiveFunctions","title":"Posterior objective","text":"","category":"section"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"posterior_objective","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.posterior_objective","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.posterior_objective","text":"posterior_objective(data::FittingData, model::Function,distribution::Function, prior = λ-> 1)\n\nReturn the unnormalized posterior density function p(λ).\n\nUsing the default prior λ-> 1, e.g. py passing only the first two arguments, leads to the likelihood objective for a maximum likelihood fit.\n\nAnalytical expression\n\nindependent data points x_i\ndependent data points y_i\nerrors Δy_i (defaulting to 1)\nmodel function m\ndistributions: p_i\nprior distribution: p_0\n\np(lambda) = p_0(lambda) cdot prod_i=1^N p_i(y_im(x_ilambda)Delta y_i)\n\n\n\n\n\n","category":"function"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"log_posterior_objective","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.log_posterior_objective","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.log_posterior_objective","text":"log_posterior_objective(data::FittingData,model::ModelFunctions, log_prior::Function = log_uniform_prior)\n\nReturn the logarithmic posterior density function L_p(λ). The model distributions and log-prior are assumed to be already in logarithm form.\n\nUsing the default prior, e.g. py passing only the first two arguments, leads to the logarithmic likelihood objective for a maximum likelihood fit.\n\nAnalytical expression\n\nindependent data points x_i\ndependent data points y_i\nerrors Δy_i (defaulting to 1)\nmodel function m\nlogarithmic distributions: L_i\nlogarithmic prior distribution: L_0\n\nL_p(lambda) = L_0(lambda) + sum_i=1^N L_i(y_im(x_ilambda)Delta y_i)\n\n\n\n\n\n","category":"function"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"log_posterior_partials","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.log_posterior_partials","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.log_posterior_partials","text":"log_posterior_partials(data::FittingData,model::ModelFunctions, log_distribution_derivatives, prior_partials::Union{Nothing,AbstractArray{F,N}} = nothing) where {F <: Function, N}\n\nReturn the partial derivatives w.r.t. the parameters [∂_1 L_p(λ),…,∂_n L_p(λ)] of the log-posterior function L_p(λ).\n\nThe partial derivatives (∂_μ m)(x,λ) of the model function must be specified in the ModelFunctions object model.\nThe log_distribution_derivatives can either be a function (same derivative for all i), or an array of functions (∂_m L_i)(y,m,Δy)\nThe prior_partials can either be a nothing (for the log-likelihood), or an array of functions (∂_μ L_0)(λ).\n\nAnalytical expression\n\nindependent data points x_i\ndependent data points y_i\nerrors Δy_i (defaulting to 1)\nmodel function m\nlogarithmic distributions: L_i\nlogarithmic prior distribution: L_0\npartial derivatives of model function in λ: ∂_μ m\npartial derivatives of the log-distributions in m: ∂_m L_i\npartial derivatives of the log-prior in λ: ∂_μ L_0\n\npartial_mu L_p(lambda) = partial_mu L_0(lambda) + sum_i=1^N  (partial_m L_i)(y_i m(x_ilambda) Delta y_i)cdot (partial_mu m)(x_ilambda)\n\n\n\n\n\n","category":"function"},{"location":"FittingObjectiveFunctions/API/","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions","text":"log_posterior_gradient","category":"page"},{"location":"FittingObjectiveFunctions/API/#FittingObjectiveFunctions.log_posterior_gradient","page":"FittingObjectiveFunctions","title":"FittingObjectiveFunctions.log_posterior_gradient","text":"log_posterior_gradient(data::FittingData,model::ModelFunctions, log_distribution_derivatives, prior_partials::Union{Nothing,AbstractArray{F,N}} = nothing) where {F <: Function, N}\n\nReturn the gradient function grad!(gradient,λ) for the log-posterior function L_p(λ). The gradient function grad! mutates (for performance) and returns the gradient. The elements of gradient do not matter, but the type and length must fit.\n\nThe partial derivatives (∂_μ m)(x,λ) of the model function must be specified in the ModelFunctions object model.\nThe log_distribution_derivatives can either be a function (same derivative for all i), or an array of functions (∂_m L_i)(y,m,Δy)\nThe prior_gradient can either be a nothing (for the log-likelihood), or a gradient mutating function of functions ∇L_0!(gradient,λ).\n\nAnalytical expression\n\nindependent data points x_i\ndependent data points y_i\nerrors Δy_i (defaulting to 1)\nmodel function m\nlogarithmic distributions: L_i\nlogarithmic prior distribution: L_0\npartial derivatives of model function in λ: ∂_μ m\npartial derivatives of the log-distributions in m: ∂_m L_i\nresulting/mutated log-prior gradient in λ: ∇ L_0\n\nnabla L_p(lambda) = nabla L_0(lambda) + sum_mu sum_i=1^N  (partial_m L_i)(y_i m(x_ilambda) Delta y_i)cdot (partial_mu m)(x_ilambda)  vece_mu\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#API","page":"AdaptiveDensityApproximation","title":"API","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/#Create-new-grids","page":"AdaptiveDensityApproximation","title":"Create new grids","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"create_grid","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.create_grid","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.create_grid","text":"create_grid(axis_ticks::AbstractArray...;initial_weight = 1.0, exclude_strings = [\"\"],string_length = 10)\n\nCreate a multidimensional grid, where the axis_ticks define the corner points of the blocks.\n\nFor each dimension a separate array of axis-ticks is required. Each axis-ticks array must have at least 3 elements.\n\nKeywords\n\ninitial_weight: Initial weight for the blocks.\nexclude_strings: Strings that should not be used for the block names / keys.\nstring_length: Length for the block names / keys.\n\n\n\n\n\ncreate_grid(axis_ticks::AbstractArray;initial_weight = 1.0, exclude_strings = [\"\"],string_length = 10)\n\nCreate a one-dimensional grid where the axis_ticks define the start/end points of the intervals.\n\nThere must be at least 3 elements in the axis_ticks array.\n\nKeywords\n\ninitial_weight: Initial weight for the intervals.\nexclude_strings: Strings that should not be used for the block names / keys.\nstring_length: Length for the block names / keys.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#Approximate-density-functions","page":"AdaptiveDensityApproximation","title":"Approximate density functions","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"approximate_density!","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.approximate_density!","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.approximate_density!","text":"approximate_density!(grid,f::Function; mode = :center, mesh_size = 4, volume_normalization = false)\n\nApproximate the density function f with the grid, changing the weights to the function values and return the mutated grid.\n\nmode = :center: Evaluate the density function in the center of the interval/block.\nmode = :mean: Evaluate the density function at all corner points of the interval/block and use the mean value.\nmode = :mesh: Evaluate the density function at all mesh points of the interval/block and use the mean value.\nmesh_size = 4: Number of block discretization points in each dimension. Only applicable to mode = :mesh.\nvolume_normalization = false: If true the density value is normalized to the block volume (weight = value × volume).\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#Import-and-Export","page":"AdaptiveDensityApproximation","title":"Import and Export","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"export_weights","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.export_weights","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.export_weights","text":"export_weights(grid)\n\nReturn a one-dim array containing the weights of the intervals/blocks.\n\nThe intervals/blocks are sorted by their centers. The weights are exported in this order.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"export_all","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.export_all","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.export_all","text":"export_all(grid)\n\nReturn one-dimensional arrays: centers, volumes, weights.\n\nThe arrays are sorted and exported by centers.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"import_weights!","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.import_weights!","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.import_weights!","text":"import_weights!(grid, weights)\n\nImport weights and return the mutated grid.\n\nThe intervals/blocks are sorted by their centers. The weights are imported in this order.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#Refine-a-grid","page":"AdaptiveDensityApproximation","title":"Refine a grid","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"refine!","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.refine!","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.refine!","text":"refine!(grid::Union{OneDimGrid,Grid}; block_variation::Function = default_block_variation, selection::Function = maximum, split_weights::Bool = false)\n\nSubdivide intervals/blocks in a grid based on the respective variations. Return the mutated grid and the indices of subdivided (i.e. new) blocks (indices w.r.t arrays obtained from export_weights and export_all).\n\nBy default the variation of a block is the largest difference in weights w.r.t. to its neighbors. The blocks to be subdivided are those that have the largest variation. If several blocks have the same variation, all those blocks are subdivided.\n\nChanging the selection of blocks\n\nblock_variation: Function to calculate the variation value for a block. Must use the following signature (block_center,block_volume, block_weight, neighbor_center,neighbor_volumes, neighbor_weights).\nselection: Function to select the appropriate variation value(s) from. Must have the signature (variations)  where variations is a one-dim array of the variation values.\n\nChanging the weight splitting\n\nBy default, the subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"subdivide!","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.subdivide!","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.subdivide!","text":"subdivide!(grid::Union{OneDimGrid,Grid},block_name::AbstractString; split_weights::Bool = false)\n\nSplit the block with name block_name into 2^dim sub-blocks. Return the mutated grid.\n\nChanging the weight splitting\n\nBy default, the subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#Restrict-the-grid-domain","page":"AdaptiveDensityApproximation","title":"Restrict the grid domain","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"restrict_domain!","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.restrict_domain!","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.restrict_domain!","text":"restrict_domain!(grid::OneDimGrid; lower::Real = -Inf,upper::Real = Inf, weight_distribution::Symbol = :none)\n\nRestrict a grid to the domain defined by lower and upper.\n\nweight_distribution = :linear: A split block gets the weight scaled to the proportion of the block within the domain.\nweight_distribution = :log: A split block gets the weight scaled to the proportion of the block, in a logarithmic scale, within the domain.\n\n\n\n\n\nrestrict_domain!(grid::Grid;lower = [-Inf,...,-Inf], upper = [Inf,...,Inf], weight_distribution::Symbol = :none)\n\nRestrict a grid to the domain defined by lower and upper.\n\nweight_distribution = :linear: A split block gets the weight scaled to the proportion of the block within the domain.\nweight_distribution = :log: A split block gets the weight scaled to the proportion of the block, in a logarithmic scale, within the domain.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"select_indices","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.select_indices","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.select_indices","text":"select_indices(grid::OneDimGrid; lower::Real=-Inf,upper::Real=Inf)\n\nReturn indices of intervals with centers between lower and upper. The indices correspond to the exported arrays centers, volumes and weights from export_weights and export_all.\n\n\n\n\n\nselect_indices(grid::Grid; lower= [-Inf,...,-Inf],upper=[Inf, ..., Inf])\n\nReturn indices of intervals with centers between lower and upper. The indices correspond to the exported arrays centers, volumes and weights from export_weights and export_all.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#Simple-calculations","page":"AdaptiveDensityApproximation","title":"Simple calculations","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"sum(::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"AdaptiveDensityApproximation/api/#Base.sum-Tuple{Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"AdaptiveDensityApproximation","title":"Base.sum","text":"sum(grid::Union{OneDimGrid, Grid}; lower = nothing, upper = nothing, weight_distribution::Symbol = :none)\n\nReturn the sum of all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"sum(::Function,::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"AdaptiveDensityApproximation/api/#Base.sum-Tuple{Function, Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"AdaptiveDensityApproximation","title":"Base.sum","text":"sum(f::Function,grid::Union{OneDimGrid, Grid}; lower = nothing, upper = nothing, weight_distribution::Symbol = :none)\n\nReturn the sum of f(weight) for all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"prod(::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"AdaptiveDensityApproximation/api/#Base.prod-Tuple{Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"AdaptiveDensityApproximation","title":"Base.prod","text":"prod(grid::Union{OneDimGrid, Grid}; lower = nothing, upper = nothing, weight_distribution::Symbol = :none)\n\nReturn the product of all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"prod(::Function,::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"AdaptiveDensityApproximation/api/#Base.prod-Tuple{Function, Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"AdaptiveDensityApproximation","title":"Base.prod","text":"prod(f::Function,grid::Union{OneDimGrid, Grid}; lower = nothing, upper = nothing, weight_distribution::Symbol = :none)\n\nReturn the product of f(weight) for all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"integrate","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.integrate","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.integrate","text":"integrate(grid)\n\nReturn the sum of volume × weight for the intervals/blocks.\n\nWhen the grid approximates a density φ with the weights of the intervals/blocks, integrate(grid) approximates the integral of the density over the grid domain: ∫_grid φ dV.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#Integral-models","page":"AdaptiveDensityApproximation","title":"Integral models","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"integral_model","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.integral_model","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.integral_model","text":"integral_model(grid,f::Function, g::Function = f)\n\nCreate a model for the integral ∫_grid f(x,y,φ(y),...) dy. Returns\n\nmodel function: (x,λ,args...) -> ∑_i block[i].volume × f(x,block[i].center,λ[i],args...)\ninitial parameter based on block weights: λ_0 = [block.weight for block in grid]\ncomponents of the sum as array of functions: [(x,λ,args...) -> block[i].volume × g(x,block[i].center,λ[i],args...) for i]\n\nThe functions f and g should have the arguments (x,center,weight,args...).  \n\nPartial derivatives\n\nThe optional function g can be used to obtain the partial derivatives of the model function w.r.t. λ as array of functions. For this, construct g such that\n\ng(x,c,w) = ∂_w f(x,c,w)\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#Numeric-PDF-and-CDF","page":"AdaptiveDensityApproximation","title":"Numeric PDF and CDF","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"get_pdf","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.get_pdf","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.get_pdf","text":"get_pdf(grid;normalize::Bool = true)\n\nReturn the discrete empirical pdf function of a grid. For this, the grid is understood as histogram, where the blocks are the bins, and the weights are the corresponding values. If normalize = true the values are normalized s.t. the sum of all values is 1.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"get_cdf","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.get_cdf","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.get_cdf","text":"get_cdf(grid;normalize::Bool = true)\n\nReturn the discrete empirical cdf function of a grid. For this, the grid is understood as histogram, where the blocks are the bins, and the weights are the corresponding values. If normalize = true the values are normalized s.t. the sum of all values is 1.\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/#Grid-slices","page":"AdaptiveDensityApproximation","title":"Grid slices","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"get_slice","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.get_slice","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.get_slice","text":"get_slice(grid::Grid, slice_selection)\n\nReturn a grid of blocks (from grid) that intersect with a slice defined by slice_selection.\n\nFor example: the y-axis is defined by slice_selection = [0,nothing,0], the y-z-plane at x = 5 is defined by slice_selection = [5,nothing,nothing], etc..\n\n\n\n\n\n","category":"function"},{"location":"AdaptiveDensityApproximation/api/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"dimension","category":"page"},{"location":"AdaptiveDensityApproximation/api/#AdaptiveDensityApproximation.dimension","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation.dimension","text":"dimension(grid)\n\nReturn the dimension of the grid. \n\n\n\n\n\n","category":"function"},{"location":"QuickStart/#quick_start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The most convenient, and recommended, way to analyze dose-response data is to use the AntibodyMethodsDoseResponseConvenience package. This tutorial will not cover all details (e.g. the internal procedure), but present a short introduction to get started. To see all details and available options, please have a look at the AnitbodyMethodsDoseResponseConvenience API.","category":"page"},{"location":"QuickStart/#Starting-point","page":"Quick start","title":"Starting point","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Suppose, a dose-response experiment with 3 replicates was conducted, leading to the following dose-response curves:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"using AntibodyMethodsDoseResponseConvenience, Measures # hide\nresults, data, replicates =  load_results(\"examples/default_concentrations\") # hide\n\nscatter(data.independent, replicates[1].dependent, xaxis = :log, label = \"replicate 1\", legend = :topleft, xlabel = \"concentration\", ylabel = \"response\") # hide\nscatter!(data.independent, replicates[2].dependent, xaxis = :log, label = \"replicate 2\", markershape = :rect) # hide\nscatter!(data.independent, replicates[3].dependent, xaxis = :log, label = \"replicate 3\", markershape = :utriangle) # hide","category":"page"},{"location":"QuickStart/#Loading-Data","page":"Quick start","title":"Loading Data","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Importing general data into Julia is not the scope of the AntibodyMethods packages. For this, use e.g. DelimitedFiles.jl or CSV.jl in conjunction with DataFrames.jl. Nevertheless, as short introduction, assume that the data is stored in a csv file, where the columns are (concentrations, replicate 1, ..., replicate 3). Using DelimitedFiles.jl the data can be imported as follows:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"using DelimitedFiles\ncsv_data = readdlm(\"path_to_file\")","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"csv_data = hcat(data.independent, replicates[1].dependent,replicates[2].dependent,replicates[3].dependent) # hide","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"To separate the different columns into independent arrays, as is needed in the following, use:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"conc  = csv_data[:,1] # concentrations\nrep_1 = csv_data[:,2] # replicate 1\nrep_2 = csv_data[:,3] # replicate 2\nrep_3 = csv_data[:,4] # replicate 3\nnothing #hide","category":"page"},{"location":"QuickStart/#Defining-a-fitting-condition","page":"Quick start","title":"Defining a fitting condition","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Before the data can be analyzed (model fitting), it needs to be summarized in a FittingCondition object. A FittingCondition object contains both the data and the fitting instructions, which can be specified with keywords. The (recommended) default analysis can be obtained by only passing the data, and the scale keyword.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"fitting_condition = FittingCondition(conc, rep_1,rep_2,rep_3, scale = 500, path = \"path_to_store_results\")\nnothing # hide","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: The scale keyword\nTo avoid overfitting of sparse, noisy dose-response data, some sort of regularization constraint is necessary. The scale keyword determines the scale of a penalty term to prevent jagged/spiky histograms. Not using the scale keyword results in a weighted least squares objective.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"warning: Inappropriate scale value\nToo small scale values only lead to an inefficient least squares objective. Too large scale values, however, can prevent the model to replicate the data at all. In cases, where the fitting result does not correspond to the data at all, try significantly smaller (orders of magnitude) scale values.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: The path keyword\nSince curve-fitting can be a time-consuming process, it is recommended to save the results into files. This allows to re-plot the results at a later time, without having to re-run the fitting process. The path keyword defines the directory for the result files. If path=\"\", which is the default option, no files are saved.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"tip: Different measurement errors\nConstructing a FittingCondition object by passing the different replicate responses will default to the standard deviation of the data points for the measurement error. If only a single response is used, the replicates field will be empty (nothing) and the measurement errors are set to ±1. Different errors can be used by constructing the FittingData object manually:errors = 0.1 .* responses\ndata = FittingData(concentrations,responses, errors)\nfitting_condition = FittingCondition(data, scale = 500, path = \"path_to_store_results\")","category":"page"},{"location":"QuickStart/#Fitting-a-condition","page":"Quick start","title":"Fitting a condition","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"After defining a FittingCondition, the data can be analyzed, i.e. fitting the antibody-binding model to the data to obtain the estimated K_tau-density. Since the fitting instructions are already contained in the FittingData object, fitting the data is just a simple function call:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"results, data, replicates = fit_condition(fitting_condition)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"fit_condition returns an AdaptiveResult object results, the data as FittingData object and the replicates as array of FittingData objects for the respective replicates. If a path is specified for the FittingCondition, the returned objects are also saved into files.","category":"page"},{"location":"QuickStart/#Loading-results*","page":"Quick start","title":"Loading results*","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"In general, it is not necessary to load the results, as fit_condition returns all results. However, since the fitting process is time-consuming, it is a good idea to save the results into files (see path keyword above). After e.g. a restart of Julia, the results can be loaded as follows:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"results, data, replicates = load_results(\"path_to_stored_results\")","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"This allows to re-plot the results at a later time, without the need to re-run the analysis.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"warning: Warning\nThe results, data and replicates are saved with Serialization.jl. Loading objects into a new instance of Julia does not re-instantiate referenced functions. In other words, the distribution functions of loaded FittingData objects do not work. Hence, loaded FittingData objects cannot be used for fitting. Instead, one should define new FittingData functions from scratch, e.g. bynew_data = FittingData(data.independent, data.dependent, data.errors, distributions = ....)The default distributions created by the FittingCondition constructor are(y,m,Δy)-> -(y-m)^2/Δy^2","category":"page"},{"location":"QuickStart/#Plotting-the-results","page":"Quick start","title":"Plotting the results","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"To visualize the results, different plotting functions are provided. The most straightforward one is bin_analysis_plot, which returns 2 plots, the dose-response plot and the density plot:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"using Measures\ndr_plot, density_plot = bin_analysis_plot(results,data,replicates)\nplot(dr_plot, density_plot, layout = (1,2), size = (800,300), margins = 4mm)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The Measures package is used here, to define the margins between the individual plots.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: Plot objects\nAntibodyMethodsDoseResponseConvenience uses Plots.jl in the background to generate the plots. All methods and options of Plots.jl are immediately available; it is not necessary to import the Plots with  using Plots. The returned plots dr_plot and density_plot are full plot objects, that can be saved directly with savefig(dr_plot,\"file_name\"). Plots.jl also allows to re-draw plot objects, allowing to compose images (see Partial plotting and the combination of plots).","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The second plotting function is peak_analysis_plot, which visualizes the effect of different peaks on the dose-response curve:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"individual_dr_plot, cumulative_dr_plot, peak_plot = peak_analysis_plot(results, data)\nplot(individual_dr_plot, cumulative_dr_plot, peak_plot, layout = (2,2), size = (800,600))","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The top-left plot shows the individual dose-response curves of the different peaks (lower-left plot) as they would appear if only the respective peak was present alone. The cumulative plot (top-right) shows the contribution of each peak to the total dose-response curve.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: Selection of peaks\nWithout additional keywords, the peaks are determined automatically using peak_detection. Peak regions can also be manually selected. E.g. two isolated ranges 10^-710^-5 and 10^-4 10^-3 could be selected using bins = [[1e-7,1e-5],[1e-4,1e-3]].","category":"page"},{"location":"QuickStart/#partial_plotting","page":"Quick start","title":"Partial plotting and the combination of plots","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Note that the peak analysis plots did not contain the replicates. This is by design, as the different plots can be combined. For this, we create a partial bin_analysis_plot, where only the data points and the replicates are plotted:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"dr_data_plot, empty_density_plot = bin_analysis_plot(nothing,data, replicates)\nplot(dr_data_plot)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Setting any of the arguments to nothing will omit the argument in the plot. E.g. to just plot the resulting curve, without the data bin_analysis_plot(results,nothing,nothing) would be used.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The cumulative dose-response, i.e. the contribution of the peaks to the total dose-response curve, can now be plotted on top of the data plot dr_data_plot, using the additional keyword cumulative_dr_plot = dr_data_plot. Since the data points are already contained in the dr_data_plot, they should not be plotted again with the peak_analysis_plot, hence the nothing:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"individual_dr_plot, cumulative_dr_plot, peak_plot = peak_analysis_plot(results, nothing, cumulative_dr_plot = dr_data_plot)\nplot(cumulative_dr_plot, peak_plot, layout = (1,2), size = (800,300), margins = 4mm)","category":"page"},{"location":"QuickStart/#plotting_options","page":"Quick start","title":"Plotting options","text":"","category":"section"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The plotting functions bin_analysis_plot, peak_analysis_plot and uncertainty_plot use keyword-generating functions to modify the plotting options. The keyword-generating functions generate keywords and the default keyword arguments for the plot, but allow to overwrite the arguments for the individual keywords. For example the data_options function generate the following keywords:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"data_options()","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"The individual keywords can by changed when calling the function. Furthermore, it is possible to add new keywords:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"data_options(label = \"new label text\", markershape = :utriangle)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"There is no need to save the resulting keyword arguments. The keyword generating function can be called (as keyword argument) in the plotting function:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"dr_plot, empty_plot = bin_analysis_plot(results,data, replicates,\n\tdata_arguments = data_options(label = \"new label text\", markershape = :utriangle)\n\t)\nplot(dr_plot)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"info: Why keyword generating functions?\nThe first idea to allow plot modifications involves global keywords, that could then be changed individually. However, different objects of the plots (e.g. the result and the data) have coinciding keywords, e.g. the color. But writing new, unique keywords for all the existing Plots.jl keywords is impossible.Hence tuples of keywords that correspond to the different parts of the plot (e.g. the result, the data and the replicates) are used. This allows to use the same keyword but with different options. E.g. data_arguments expects a tuple of keywords, which then only affect the plotting of the data points.To define the default behavior, a default tuple of keywords could be used. However, then if only one keyword needed to be changed, the user would have to create a new tuple, copying over the unchanged keywords, which is inconvenient. Thus, keyword-(tuple) generating functions are provided that produce the default keyword tuple but allow to change individual keywords. In fact data_arguments = data_options() is set as default internally.","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"Another example where generating functions are used to modify the plot, are the base-plot functions. In the previous section (Partial plotting and the combination of plots) it was used that bin_analysis_plot, peak_analysis_plot and uncertainty_plot plot on top of preexisting plots. In fact, even when e.g. dr_plot is not explicitly changed, dr_plot = dr_base_plot() is used to create an empty plot (with some options pre-configured). Calling dr_base_plot allows to change those pre-configured options:","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"dr_plot, empty_plot = bin_analysis_plot(results,data, replicates,\n\t\tdr_plot = dr_base_plot(xlabel = \"concentrations\", legend = :none)\n\t\t)\nplot(dr_plot)","category":"page"},{"location":"QuickStart/","page":"Quick start","title":"Quick start","text":"A complete list of these generating functions and how they are used in the different plotting functions can be found in the AnitbodyMethodsDoseResponseConvenience API.","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/#Background:-Posterior-probability","page":"Background","title":"Background: Posterior probability","text":"","category":"section"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"The posterior objective (and the Log posterior objective which is numerically favorable) allows to define more general objective functions. Form a Bayesian perspective, one is interested in the probability density for a particular parameter lambda given the data x_i_i=1^N y_i_i=1^N and the model m(xlambda):","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"p(lambda mid x_i_i=1^N y_i_i=1^N m)","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/#Applying-Bayes'-theorem","page":"Background","title":"Applying Bayes' theorem","text":"","category":"section"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"Using Bayes' theorem, the probability density can be rewritten as:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"p(lambda mid x_i_i=1^N y_i_i=1^N m) = fracell(y_i_i=1^N mid x_i_i=1^N  lambda m )cdot p_0(lambdamid x_i_i=1^N m)p(y_i_i=1^N mid x_i_i=1^N  m)","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"The denominator is but a normalization constant, that does not depend on lambda, i.e. can be ignored for optimization problems (and MCMC sampling):","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"p(lambda mid x_i_i=1^N y_i_i=1^N m) propto ell(y_i_i=1^N mid x_i_i=1^N  lambda m )cdot p_0(lambdamid x_i_i=1^N m)","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"Because of the proportionality, one may refer to the right hand side as unnormalized posterior.","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"ell is a proper probability distribution for y_i_i=1^N given x_i_i=1^N lambda m. However, it can also be regarded as function of lambda, for fixed x_i_i=1^N, y_i_i=1^N and m (which is needed, since the data is fixed, but different parameters need to be tested for model fitting). In this case, one calls it the likelihood function of lambda. It is no longer a proper probability density (still positive but no longer normalized).\np_0 is the so called prior distribution. It determines the probability of the parameters, before the data was obtained. This is sometimes called belief in parameters or initial knowledge.","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"default: The prior and objectivity\nA common critique is, that the prior is not objective. While the choice of prior can be subjective, it must be explicitly stated making all assumptions transparent. This allows for an objective comparison of the different approaches.In fact, there are two common types of priors in least squares fitting.p_0(lambdamid x_i_i=1^N m) = 1, i.e. a uniform prior. Since one usually uses a computer, there is a largest number b infty and a smallest number a  -infty that the computer can use. Then one may choose the uniform distribution p_0(lambda mid x_i_i=1^N m) = frac1b-a. Sine the posterior probability is only considered up to proportionality, one can simply use p_0(lambdamid x_i_i=1^N m) = 1. This leads to a maximum likelihood objective.\nIn ill-defined problems, it is common practice to use some kind of regularization. In some cases, these regularizations correspond to certain priors. For example, the Tikhonov regularization essentially uses the prior p_0(lambdamid x_i_i=1^N m) propto exp(-Gamma lambda ^2).","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/#Independent-data-points","page":"Background","title":"Independent data points","text":"","category":"section"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"A common assumption is that the data points are independent. While this is not a necessity, writing general likelihood functions is usually not trivial. If the data points are independent, the likelihood function becomes a product of likelihood functions for the individual data point likelihoods:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"ell(y_i_i=1^N mid lambda x_i_i=1^N m ) = prod_i=1^N ell_i(y_imid lambda x_i m)","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"Note that the likelihoods can differ for the different data points, denoted by ell_i here.  Thus the posterior probability / the objective function becomes","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"p(lambda mid x_i_i=1^N y_i_i=1^N m) propto  p_0(lambdamid x_i_i=1^N m) prod_i_1^n ell_i(y_imid lambda x_im)","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"In general, x_i is only the measured value, while the true value mathcalX_i is unknown. If the distribution p_i(mathcalX_imid lambda x_i m) is known, marginalization can be used to express the likelihood","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"ell(y_imid lambda x_i m) = int ell(y_i mid mathcalX_i lambda x_i m)cdot p(mathcalX_imid lambda x_im)  dmathcalX_i","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"It can happen, that this integral can only be solved numerically. Since this is computationally expensive, and needs to be redone for every new value of lambda, the resulting posterior distribution is often not suited for optimization/sampling purposes. Another approach could be data-augmentation, e.g. to sample ell(y_i mathcalX_imid lambda x_i m), which is not the scope of this package.","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"The likelihood ell(y_imid mathcalX_i lambda x_i m) is essentially given by the probability distribution q_i(y_imid mathcalY_i) to measure y_i when the true value is mathcalY_i, since mathcalY_i = m(mathcalX_ilambda) by assumption of the model:","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"ell(y_i mid mathcalX_i lambda x_i m) = q_i(y_imid m(mathcalX_i lambda))","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/#No-x-uncertainty","page":"Background","title":"No x-uncertainty","text":"","category":"section"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"A convenient situation is, when the distinction between x_i and mathcalX_i can be neglected, e.g. because the independent variable can be measured with high precision. Then p_i(mathcalX_imid lambda x_i m) becomes a Dirac distribution, and","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"ell(y_imid lambda x_i m) = q(y_imid m(x_ilambda))","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"Hence, the posterior probability reads ","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"p(lambda mid x_i_i=1^N y_i_i=1^N m) propto  p_0(lambdamid x_i_i=1^N m) prod_i_1^n q_i(y_imid m(x_ilambda))","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/#Retrieving-the-LSQ-objective","page":"Background","title":"Retrieving the LSQ objective","text":"","category":"section"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"Using the aforementioned uniform prior p_0(lambdamid x_i_i=1^N m) = 1 and assuming normal distributions for q_i with standard deviations Delta y_i leads to","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"beginaligned\np(lambda mid x_i_i=1^N y_i_i=1^N m) propto   prod_i_1^n frac1sqrt2piDelta y_iexpleft(- frac(y_i - m(x_ilambda))^22Delta y_iright)  \npropto prod_i_1^n expleft(- frac(y_i - m(x_ilambda))^22Delta y_iright) \n quad = expleft(- sum_i=1^N frac(y_i - m(x_ilambda))^22Delta y_iright)\nendaligned","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"Maximizing this function is equivalent to minimizing","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"sum_i=1^N frac(y_i - m(x_ilambda))^22Delta y_i","category":"page"},{"location":"FittingObjectiveFunctions/posterior_background/","page":"Background","title":"Background","text":"which is the weighted least squares objective (up to a factor frac12) function (see Background: LSQ).","category":"page"},{"location":"API/#API","page":"AntibodyMethodsDoseResponse","title":"API","text":"","category":"section"},{"location":"API/#Measurement-data-processing","page":"AntibodyMethodsDoseResponse","title":"Measurement data processing","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"dose_response_check","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.dose_response_check","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.dose_response_check","text":"dose_response_check(fitting_data::FittingData)\n\nTest if the FittingData object satisfies properties for dose-response data:\n\nonly real numbers\nnumbers must be positive\nno NaN or Inf in the data set\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"normalize_data","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.normalize_data","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.normalize_data","text":"normalize_data!(fitting_data::FittingData; offset::Real = 0, reference::Union{Nothing,Real} = nothing)\n\nReturn FittingData object with normalized response data and errors.\n\nreference = nothing: The reference signal to normalize the responses to. If reference = nothing, the maximal response is used a reference point.\noffset = 0: Signal offset to be subtracted (applies to both the responses and the reference point).\n\nThe normalization of the responses and errors are:\n\nnew_responses = (responses - offset) / (reference - offset)\nerrors =  errors / (reference - offset)\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"normalize_data!","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.normalize_data!","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.normalize_data!","text":"normalize_data!(fitting_data::FittingData; offset::Real = 0, reference::Union{Nothing,Real} = nothing)\n\nNormalize fitting_data object by mutation.\n\nreference = nothing: The reference signal to normalize the responses to. If reference = nothing, the maximal response is used a reference point.\noffset = 0: Signal offset to be subtracted (applies to both the responses and the reference point).\n\nThe normalization of the responses and errors are:\n\nnew_responses = (responses - offset) / (reference - offset)\nerrors =  errors / (reference - offset)\n\n\n\n\n\n","category":"function"},{"location":"API/#Depletion-correction-of-measurement-data","page":"AntibodyMethodsDoseResponse","title":"Depletion correction of measurement data","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"scale_bound","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.scale_bound","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.scale_bound","text":"scale_bound(fitting_data::FittingData)\n\nGet the upper bound for the scale factor β between the responses r_i and the (initial) antibody concentrations a_i, s.t.  a_i - β*r_i ≥ 0.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"simple_depletion_correction","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.simple_depletion_correction","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.simple_depletion_correction","text":"simple_depletion_correction(fitting_data::FittingData,scale::Real)\n\nReturn depletion-corrected FittingData object\n\nThe concentrations are corrected to concentration - scale * response.\n\n\n\n\n\nsimple_depletion_correction(fitting_data::FittingData)\n\nReturn depletion-corrected FittingData object using the largest possible scale factor.\n\nThe concentrations are corrected to concentration - scale * response.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"simple_depletion_correction!","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.simple_depletion_correction!","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.simple_depletion_correction!","text":"simple_depletion_correction!(fitting_data::FittingData,scale::Real)\n\nDepletion-correct fitting_data by mutation.\n\nThe concentrations are corrected to concentration - scale * response.\n\n\n\n\n\nsimple_depletion_correction!(fitting_data::FittingData)\n\nDepletion-correct fitting_data by mutation, using the largest possible scale factor.\n\nThe concentrations are corrected to concentration - scale * response.\n\n\n\n\n\n","category":"function"},{"location":"API/#Models","page":"AntibodyMethodsDoseResponse","title":"Models","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"accumulation_model","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.accumulation_model","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.accumulation_model","text":"accumulation_model(grid::OneDimGrid; offset = nothing)\n\nCreate a multi-epitope accumulation model. Returns (model,λ,centers,volumes) where \n\nmodel is a ModelFunctions object.\nλ is an initial parameter array (the weights of the grid and the offset if offset != nothing). If offset != nothing, the last element is the offset parameter λ[end] = offset.\ncenters and volumes are the remaining properties of the grid, see export_all\n\nModel function\n\nThe following model function and partial derivatives are used:\n\ntextmodel(alambda) = lambda_e + sum_i lambda_i left(1-e^-fracac_iright)  approx  lambda_e + sum_i int_l_i^u_i fraclambda(k)u_i-l_ileft(1-e^-fracakright)  dk \n\npartial_lambda_j textmodel(alambda) = 1-e^-fracac_i quad qquad partial_lambda_e textmodel(alambda) = 1\n\nwhere a is the antibody concentration, c_i are the centers of the grid intervals [u_i,l_i] and λ_e is the offset (if offset != nothing).\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"langmuir_model","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.langmuir_model","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.langmuir_model","text":"langmuir_model(grid::OneDimGrid; offset = nothing)\n\nCreate a multi-epitope Langmuir model. Returns (model,λ,centers,volumes) where \n\nmodel is a ModelFunctions object.\nλ is an initial parameter array (the weights of the grid and the offset if offset != nothing). If offset != nothing, the last element is the offset parameter λ[end] = offset.\ncenters and volumes are the remaining properties of the grid, see export_all.\n\nModel function\n\nThe following model function and partial derivatives are used:\n\ntextmodel(alambda) = lambda_e + sum_i fraclambda_icdot a (u_i - l_i) lnleft(fraca+u_ia+l_iright)  =  lambda_e + sum_i int_l_i^u_i fracfraclambda(k)u_i - l_i1+fracka  dk \n\npartial_lambda_j textmodel(alambda) = fracau_j-l_j lnleft(fraca+u_ja+l_jright)quad qquad partial_lambda_e textmodel(alambda) = 1\n\nwhere a is the antibody concentration, [l[i],u[i]] are the intervals of the grid and λ_e is the offset (if offset != nothing).\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"accumulation_inv_const_model ","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.accumulation_inv_const_model","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.accumulation_inv_const_model","text":"accumulation_inv_const_model(grid::OneDimGrid; offset = nothing)\n\nCreate a multi-epitope accumulation model with 1/K_τ = k_a * τ as constant domain. Returns (model,λ,centers,volumes) where \n\nmodel is a ModelFunctions object.\nλ is an initial parameter array (the weights of the grid and the offset if offset != nothing). If offset != nothing, the last element is the offset parameter λ[end] = offset.\ncenters and volumes are the remaining properties of the grid, see export_all\n\nModel function\n\nThe following model function and partial derivatives are used:\n\ntextmodel(alambda) = lambda_e + sum_i lambda_i left(1+frac1acdot(u_i-l_i)left(e^-a u_i-e^-a l_i right) right) =   lambda_e + sum_i int_l_i^u_i fraclambda(k)u_i-l_ileft(1-e^-a kright)  dk \n\npartial_lambda_j textmodel(alambda) = 1+frac1acdot(u_i-l_i)left(e^-a u_i-e^-a l_i right) quad qquad partial_lambda_e textmodel(alambda) = 1\n\nwhere a is the antibody concentration, c_i are the centers of the grid intervals [u_i,l_i] and λ_e is the offset (if offset != nothing).\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"langmuir_inv_const_model","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.langmuir_inv_const_model","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.langmuir_inv_const_model","text":"langmuir_inv_const_model(grid::OneDimGrid; offset = nothing)\n\nCreate a multi-epitope Langmuir model with 1/K_τ = k_a * τ as constant domain. Returns (model,λ,centers,volumes) where \n\nmodel is a ModelFunctions object.\nλ is an initial parameter array (the weights of the grid and the offset if offset != nothing). If offset != nothing, the last element is the offset parameter λ[end] = offset.\ncenters and volumes are the remaining properties of the grid, see export_all\n\nModel function\n\nThe following model function and partial derivatives are used:\n\ntextmodel(alambda) = lambda_e + sum_i lambda_i left(1+ frac1acdot (u_i-l_i) lnleft(fraca l_i +1a u_i +1right)right)  = lambda_e + sum_i int_l_i^u_i fracfraclambda(k)u_i - l_i1+frac1acdot k  dk  \n\npartial_lambda_j textmodel(alambda) = 1+ frac1acdot (u_i-l_i) lnleft(fraca l_i +1a u_i +1right)quad qquad partial_lambda_e textmodel(alambda) = 1\n\nwhere a is the antibody concentration, [l[i],u[i]] are the intervals in the grid and λ_e is the offset (if offset != nothing).\n\n\n\n\n\n","category":"function"},{"location":"API/#Result-type","page":"AntibodyMethodsDoseResponse","title":"Result type","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"DoseResponseResult","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.DoseResponseResult","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.DoseResponseResult","text":"struct DoseResponseResult\n\nData type to store dose-response result data (e.g. from a dose-response-curve fitting or a simulation).\t\n\nFields\n\nconcentrations: Antibody concentrations.\nresponses: Response values.\n\nDefault constructor\n\nDoseResponseResult(concentrations,responses)\n\nModel constructor\n\nDoseResponseResult(grid::OneDimGrid,concentrations; offset::Real = 0,model::Function = accumulation_model)\n\nCalculate a dose-response curve from a K_τ grid and a model for given concentrations. The offset value is a global additive shift for all response values.\n\nThe available model functions are accumulation_model, accumulation_inv_const_model, langmuir_model and langmuir_inv_const_model.\n\n\n\n\n\n","category":"type"},{"location":"API/#Adaptive-fitting","page":"AntibodyMethodsDoseResponse","title":"Adaptive fitting","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"AdaptiveOptions","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.AdaptiveOptions","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.AdaptiveOptions","text":"mutable struct AdaptiveOptions\n\nData type to define adaptivedoseresponse_fit options.\n\nConstructor\n\nAdaptiveOptions(keywords...)\n\nThe following keywords (with default values) are available:\n\nname::AbstractString = \"Adaptive optimization: The name that is used when show_progress==true.\nshow_progress::Bool = true: Show progress in standard output.\niterations::Integer = 1: Number of refinement iterations.\nmodel::Function = accumulation_model: The model-function that is used for the data-fit. The available model functions are accumulation_model, accumulation_inv_const_model, langmuir_model and langmuir_inv_const_model.\noffset = nothing: Offset parameter for the model function. If nothing, no offset is used.\nobjective::Symbol = :lsq. The objective function for the data-fit. Available are :lsq, :posterior and :log_posterior.\nprior_generator::Function = default_prior_generator: The function that generates the prior. The function must have the signature (grid_centers,grid_volumes,offset) and must return a function λ-> prior(λ). The default_prior_generator generates a uniform prior λ-> 0 for the log-posterior objective.\ndistribution_derivatives = nothing: Array of partial derivatives of the logarithmic distributions for the log-posterior objective. See log_posterior_gradient.\nprior_gradient_generator = default_prior_gradient_generator: The function that generates the prior-gradient (see  log_posterior_gradient). The function must have the signature (grid_centers,grid_volumes,offset) and must return a function λ-> ∇prior(λ). The default_prior_gradient_generator returns nothing which internally corresponds to the uniform prior for the log-posterior objective.\nblock_variation::Function = log_area_scaled_variation and selection::Function = maximum are the refinement options of refine!.\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"area_scaled_variation","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.area_scaled_variation","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.area_scaled_variation","text":"area_scaled_variation(center, volume, weight, neighbor_centers, neighbor_volumes, neighbor_weights)\n\nBlock variation function for refine!. Variation value based on the difference of the weights, scaled with the area (volume) of the corresponding block.\n\nmean(@. abs(weight * volume - neighbor_weights * neighbor_volumes))\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"log_area_scaled_variation","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.log_area_scaled_variation","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.log_area_scaled_variation","text":"log_area_scaled_variation(center, volume, weight, neighbor_centers, neighbor_volumes, neighbor_weights)\n\nBlock variation function for refine!. Variation value based on the difference of the weight, scaled with the visible area (in a logarithmic plot) of the corresponding block.\n\nlog_volume = (log10(center + volume / 2) - log10(center - volume / 2))\nneighbor_log_volumes = @. (log10(neighbor_centers + neighbor_volumes / 2) - log10(neighbor_centers - neighbor_log_volumes / 2))\nmean(@. abs(weight * log_volume  - neighbor_weights * neighbor_log_volumes))\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"adaptive_dose_response_fit","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.adaptive_dose_response_fit","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.adaptive_dose_response_fit","text":"adaptive_dose_response_fit(initial_grid::OneDimGrid, data::FittingData, minimizer::Function; options::AdaptiveOptions=AdaptiveOptions())\n\nFit dose-response data (with adaptive grid refinements depending on the options) and return an AdaptiveResult object. The initial gird is not mutated. For the AdaptiveResult object a copy of the gird is created.\n\nMinimizer function\n\nThe sign of Posterior and Log-posterior objectives is flipped for consistency reasons. A minimizer needs to be used for all objectives (:lsq, :posterior, :log_posterior).\nminimizer: This is the function that minimizes the objective function. It needs to be specified by the user and must have the signature (objective_function, objective_gradient!,parameters).\nThe objective_function always has the signature (parameters).\nThe objective_gradient! can be nothing. Otherwise it has the signature (gradient_vector, parameter). It mutates the gradient_vector and returns the mutated gradient_vector.\nparameters is the initial parameter array to start minimization from.\n\nGradients for minimization\n\nWhether objective_gradient! is nothing or a proper function depends on the specified options (see AdaptiveOptions).\n\nThe :lsq objective always provides analytical gradients.\nThe :posterior objective never provides analytical gradients. \nThe:log_posterior objective only provides analytical gradients if distribution_derivatives != nothing.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"AdaptiveResult","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.AdaptiveResult","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.AdaptiveResult","text":"mutable struct AdaptiveResult\n\nData type used by adaptive_dose_response_fit to summarize the results.\n\nThe struct has the following fields:\n\nresult: The DoseResponseResult object corresponding to the fit result.\ngrid: The grid (with imported weights) corresponding to the fit result.\noptimizer: The raw result parameter.\nobjective_value: The objective-function value of optimizer.\ntime: The elapsed time for the model fit (in seconds).\n\n\n\n\n\n","category":"type"},{"location":"API/#Convenience-methods","page":"AntibodyMethodsDoseResponse","title":"Convenience methods","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"LogRange","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.LogRange","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.LogRange","text":"LogRange(start::Real,stop::Real,n::Integer, base::Real = 10.0)\n\nReturn a vector with n values logarithmically distributed between start and stop. The logarithm base can be changed with the last, optional argument.\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"peak_detection","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.peak_detection","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.peak_detection","text":"peak_detection(grid::OneDimGrid, relative_threshold::Real = 0.1; volume_normalization::Symbol = :log, fill::Bool = true)\n\nReturn (peak_group_indices,peak_group_domains) w.r.t. the relativ_ threshold.\n\npeak_group_indices the index-vectors of the peaks. The indices correspond to exported grid centers/volumes/weights (see export_weights and export_all).\npeak_group_domains contains the intervals covered by the respective peaks.\nThe cutoff threshold is determined by relative_threshold * largest_weight.\nIf fill == true, the gaps between the peaks are added to peak_group_indices and peak_group_domains.\nvolume_normalization normalizes the weights of the grid (without mutation). :none uses the raw weights. :linear divides the weights by the block volume and :log divides the weight by the block volume in a logarithmic scale.\n\n\n\n\n\n","category":"function"},{"location":"API/#Uncertainty-estimation","page":"AntibodyMethodsDoseResponse","title":"Uncertainty estimation","text":"","category":"section"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"EpitopeUncertainty","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.EpitopeUncertainty","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.EpitopeUncertainty","text":"struct EpitopeUncertainty\n\nData type to store uncertainty estimates for the weights of a K_τ grid.\n\nFields\n\nlevels: List of uncertainty levels. They can be sample quantiles or fractions of the best objective value, depending on the constructor.\nlower: Matrix of estimated lower bounds for the weights at the corresponding uncertainty levels (dimension order : [level, grid parameter index]).\nupper: Matrix of estimated upper bounds for the wights at the corresponding uncertainty levels (dimension order : [level, gird parameter index]).\nlower_offset: Vector of lower bounds for the offset parameter corresponding to the uncertainty levels.\nupper_offset: Vector of upper bounds for the offset parameter corresponding to the uncertainty levels.\n\n\n\n\n\nDefault constructor\n\nEpitopeUncertainty(levels, lower, upper, lower_offset= nothing, upper_offset = nothing)\n\n\n\n\n\nConstruction from bin-wise shifting\n\nEpitopeUncertainty(data::FittingData,grid::OneDimGrid, bins = collect(1:length(grid)); keywords...)\n\nEstimate uncertainty by shifting all grid weights uniformly, one bin at a time, while keeping the other bins fixed. Admissible weights (for a given level) are determined by calculating the objective-function value (objective function automatically generated) for the shifted weights.\n\nThe bins can be defined as vector of indices, e.g. [[1,2,3],[4,5,6]] or [1,3,5] which is converted to [[1],[3],[5]]. To obtain bin indices from the grid-domain, use select_indices.\n\nThe following keywords are available:\n\nlevels = collect(0.1:0.1:1): The uncertainty levels as fractions of the best objective value.\nsteps::Integer = 10^4: Number of intermediate shifts to be tested. The maximal shift range is determined automatically.\nbisections::Integer = 10^2: Number of interval-bisection steps to determine the maximal shift range.\nvolume_normalization = :none: Changes the scaling of the weight shifts for each individual weight in a bin. Use :none to apply the same shift for each weight. Use :linear to scale the shifts with the interval volumes corresponding to the weights.  And use :log to scale the sifts with the visual interval volumes (as they appear in a logarithmic plot) corresponding to the weights.\noptions::AdaptiveOptions = AdaptiveOptions(): The objective function is automatically generated, using the same construction as adaptive_dose_response_fit. See AdaptiveOptions and adaptive_dose_response_fit for the details. To use the best offset estimation from a fit result that included the offset parameter, add the estimated value (e.g. from an AdaptiveResult object result) to the AdaptiveOptions with the offset keyword: options = AdaptiveOptions(other_options..., offset = result.optimizer[end]).\n\n\n\n\n\nConstruction from samples\n\nEpitopeUncertainty(samples; keywords... )\n\nEstimate the uncertainty as credibility intervals (symmetric interval around the median) from samples (drawn from a posterior distribution). The samples can either be passed as array of samples (parameters) or as matrix (order: [parameter index, sample index]).\n\nThe following keywords are available:\n\nlevels = collect(0.1:0.1:1): The uncertainty levels as fractions of the best objective value.\noffset::Bool = false: If true the last parameter element is treated as offset parameter, otherwise, all parameters are treated as grid weights.\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse","text":"DoseResponseUncertainty","category":"page"},{"location":"API/#AntibodyMethodsDoseResponse.DoseResponseUncertainty","page":"AntibodyMethodsDoseResponse","title":"AntibodyMethodsDoseResponse.DoseResponseUncertainty","text":"struct DoseResponseUncertainty\n\nData type to store uncertainty estimates for the response values of a DoseResponseResult object.\n\nFields\n\nlevels: List of uncertainty levels, corresponding to the uncertainty levels of a EpitopeUncertainty object (if constructed from an EpitopeUncertainty object).\nconcentration: Vector of concentrations (no uncertainty).\nlower: Matrix of estimated lower bounds for the responses at the corresponding uncertainty level (dimension order : [level, concentration/response index]).\nupper: Matrix of estimated upper bounds for the responses at the corresponding uncertainty level (dimension order : [level, concentration/response index]).\n\n\n\n\n\nDefault constructor\n\nDoseResponseUncertainty(levels,concentrations,lower,upper)\n\n\n\n\n\nConstruction from an EpitopeUncertainty object\n\nDoseResponseUncertainty(grid::OneDimGrid,eu::EpitopeUncertainty,concentrations::AbstractVector; keywords...)\n\nEstimate the dose-response uncertainty from an EpitopeUncertainty object eu for the passed concentrations. The grid should be the grid that was used to create the EpitopeUncertainty object eu with.\n\nThe following keywords are available:\n\nbins = [collect(1:length(grid))]: The response bounds are calculated as point-wise minima/maxima of responses created from the grid weights, where one bin at a time is replaced with the EpitopeUncertainty lower and upper bound, while keeping the other weights fixed. For the minima/maxima all response values, iterating over all bins, are considered. Ideally, the bins should correspond to the bins that were used to construct the EpitopeUncertainty object eu with.\nmodel::Function = accumulation_model: The model that is used to calculate the responses from. The available model functions are accumulation_model, accumulation_inv_const_model, langmuir_model and langmuir_inv_const_model.\n\nThere is no offset keyword, as the offsets are determined by the EpitopeUncertainty object.\n\n\n\n\n\n","category":"type"},{"location":"FittingObjectiveFunctions/lsq_background/#Background:-LSQ","page":"Background","title":"Background: LSQ","text":"","category":"section"},{"location":"FittingObjectiveFunctions/lsq_background/","page":"Background","title":"Background","text":"For data points (x_iy_iDelta y_i)_i=1^N, the (weighted) least squares objective function is","category":"page"},{"location":"FittingObjectiveFunctions/lsq_background/","page":"Background","title":"Background","text":"textlsq(lambda) = sum_i=1^N frac(y_i - m(x_ilambda))^2Delta y_i^2","category":"page"},{"location":"FittingObjectiveFunctions/lsq_background/","page":"Background","title":"Background","text":"For the standard least squares objective function, one sets Δy_i = 1 for all i = 1ldotsn.","category":"page"},{"location":"FittingObjectiveFunctions/lsq_background/","page":"Background","title":"Background","text":"The optimal parameters lambda, given the data (x_iy_iDelta y_i) and the model function m(xlambda), are those that minimize the least squares objective function textlsq(lambda). An explanation for this statement can be found in Background:-Posterior-probability","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/#LSQ:-How-to-implement","page":"How to implement","title":"LSQ: How to implement","text":"","category":"section"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"Consider the data and model from Simple-example:","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"using FittingObjectiveFunctions, Plots #hide\n\nX = collect(1:10)\nY = [1.0, 1.78, 3.64, 3.72, 5.33, 2.73, 7.52, 9.19, 6.73, 8.95]\nΔY = [0.38, 0.86, 0.29, 0.45, 0.66, 2.46, 0.39, 0.45, 1.62, 1.54]\ndata = FittingData(X,Y,ΔY)\nmodel = ModelFunctions((x,λ)-> λ*x)\n\nnothing #hide","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/#LSQ:-objective-functions","page":"How to implement","title":"LSQ: objective functions","text":"","category":"section"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"The uncertainty-weighted least squares objective function can be obtained as follows:","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"weighted_lsq = lsq_objective(data,model)\nnothing # hide","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"lsq_objective returns a function that takes the model parameters λ as argument.","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"To obtain the standard least squares objective, the errors must be set to 1. Recall the shortened constructor (see FittingData):","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"data_no_errors = FittingData(X,Y)\nstandard_lsq = lsq_objective(data_no_errors,model)\nw_lsq_plot = plot(weighted_lsq, label = \"weighted lsq\", xlims = [0,2], xlabel = \"λ\", ylabel = \"lsq\") #hide\nplot!(standard_lsq, label = \"standard lsq\", xlims = [0,2], xlabel = \"λ\", ylabel = \"lsq\", color = 2) #hide","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/#LSQ:-partial-derivatives-and-gradients","page":"How to implement","title":"LSQ: partial derivatives and gradients","text":"","category":"section"},{"location":"FittingObjectiveFunctions/lsq_implementation/#Examples","page":"How to implement","title":"Examples","text":"","category":"section"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"Redefine model to obtain analytical derivatives (see ModelFunctions):","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"model = ModelFunctions((x,λ)->λ*x , partials = [(x,λ)-> x])\n∂_weighted_lsq = lsq_partials(data,model)","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"∂_weighted_lsq[1](1.1)","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"Note that lsq_partials returns a vector of abstract functions with λ as argument (one for each partial derivative), even in the 1-dimensional case.","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"∇_weighted_lsq = lsq_gradient(data,model)","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"∇_weighted_lsq([0.0],1.1) ","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"On the other hand lsq_gradient directly returns the gradient function, but with a different signature (grad_vector,λ). The argument grad_vector must be a vector of appropriate type and length, that can be mutated.","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"info: Why mutation for gradient function?\nIn some optimization algorithms, the gradient function is called multiple times during each iteration. Mutating an array allows to reduce the memory allocation overhead of creating a new gradient array every time.","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/#Partial-derivatives","page":"How to implement","title":"Partial derivatives","text":"","category":"section"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"@doc lsq_partials #hide","category":"page"},{"location":"FittingObjectiveFunctions/lsq_implementation/#Gradient","page":"How to implement","title":"Gradient","text":"","category":"section"},{"location":"FittingObjectiveFunctions/lsq_implementation/","page":"How to implement","title":"How to implement","text":"@doc lsq_gradient #hide","category":"page"},{"location":"DensityPlots/#Density-plots-for-OneDimGrid","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"","category":"section"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"Consider the following density:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"using AntibodyMethodsDoseResponseConvenience\nusing Distributions\n\np(x) = pdf(Normal(1e-5,3e-6),x)\nplot(p, xaxis = :log, xlims = [1e-10,1e-2], fill = 0, label = \"density\")","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"In the previous tutorials it was explained how this density can be approximated with a OneDimGrid and how the OneDimGrid can be plotted:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"using AdaptiveDensityApproximationRecipes\ngrid = create_grid(LogRange(1e-10,1e-2,50))\napproximate_density!(grid, p, volume_normalization = true)\nplot(grid, xaxis = :log)","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"While the grid-plot can be helpful, it can also be distracting for assessing the density approximation. Especially since the weights (and thus the bar heights) of the grid correspond to the area under the density function (for the respective interval).","category":"page"},{"location":"DensityPlots/#The-DensityPlot-recipe","page":"Density plots for OneDimGrid","title":"The DensityPlot recipe","text":"","category":"section"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"The AntibodyMethodsDoseResponseRecipes package offers a plotting recipe to plot the density that a OneDimGrid approximates (this package is automatically imported by AntibodyMethodsDoseResponseConvenience):","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"plot(DensityPlot(grid), xaxis = :log, fill = 0, volume_normalization = :linear, label = \":linear\")","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"Observe that the y-axis now has the same scale as in the density plot.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"info: volume_normalization\nThe OneDimGrid weights correspond to the number of epitopes lambda_j with K_tau in a given interval I_j, not to the density value g_j = fraclambda_jtextlength(I_j). Thus it is necessary divide the weights by the interval lengths (volume_normalization = :linear) to obtain the density. However, using the visual volumes of the logarithmic scale (volume_normalization = :log) represents the contribution of peaks to the dose-response curve more accurately (see Background: log-volume normalization). Hence, it is the default normalization despite not being the \"true\" density plot.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"plot(DensityPlot(grid), xaxis = :log, volume_normalization = :none, fill = 0, fillapha = 0.5, label = \":none = grid plot\", legend = :topleft)\nplot!(DensityPlot(grid), volume_normalization = :log, fill = 0, fillalpha = 0.5, label = \":log\")","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"With DensityAnnotations it is possible to display the total number of epitopes within selected annotation bins, on top of an already existing density plot:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"plot(DensityPlot(grid), label = \"grid\")\nplot!(DensityAnnotations(grid), xaxis = :log, \n\tvolume_normalization = :log,\n\tannotation_bins = [[1e-10,1e-6], [1e-6,1e-4],[1e-4,1e-2]],\n\tannotation_size = 10,\n\tannotation_offset = [0.2,0.1,0.2],\n\thover_points = false,\n\tannotation_color = :black\n\t)","category":"page"},{"location":"DensityPlots/#Keywords-and-default-arguments","page":"Density plots for OneDimGrid","title":"Keywords and default arguments","text":"","category":"section"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"volume_normalization = :log: This keyword is needed to estimate the height of the annotation markers. Hence it should match the choice for the density plot.\nannotation_bins = []: The selected bins as vector of vectors. The bins are selected based on the K_tau value, not based on the grid interval index. \nannotation_size = 10: Font size for the annotation labels (that show the number of epitopes within the bin).\nannotation_offset = 0.05: Offset of the annotation labels from the top of the plot (as fraction of the plot height). When a single value is provided, the offsets alternate between 0 and the provided value. Alternatively, the offsets can be provided independently for each annotation bin, by providing a length-matched array of offsets.\nhover_points = false: Only recommended if the Plotly.jl backend is used. If true, scatter points with the annotation label as tooltip are added, as Plotly.jl handles annotations differently.\nannotation_color = :black: The color for the annotation labels and bin lines.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"info: Number of epitopes\nThe \"number of epitopes\" is calculated in the dimension/unit that the response values are provided in. If the response value is the total number of bound antibody-epitope complexes, the calculated \"number of epitopes\" is indeed the number of epitopes. If the responses are measured as quantity that is only proportional to the number of bound complexes, the \"number of epitopes\" is only proportional to the actual number of epitopes, with the same proportionality constant.","category":"page"},{"location":"DensityPlots/#log_volume_normalization","page":"Density plots for OneDimGrid","title":"Background: log-volume normalization","text":"","category":"section"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"warning: log-volume and standard volume\nlog-volume means the visual volume (visual interval length) in a plot with logarithmic scale, not the logarithm of the volume!. It corresponds to volume_normalization = :log. Standard volume is the true volume (interval length), corresponding to volume_normalization = :linear.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"To illustrate the benefit of the log-volume normalization for the analysis of dose-response data, we may consider 2 peaks:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"p_A(x) =  pdf(Normal(1e-6, 3e-7),x)\np_B(x) = pdf(Normal(1e-5,3e-6),x)\np(x) = p_A(x) + p_B(x)\n\nplot(p, xaxis = :log, xlims = [1e-10,1e-2], fill = 0, label = \"density\")","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"As before, the density is approximated with a OneDimGrid:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"grid = create_grid(LogRange(1e-10,1e-2,100))\napproximate_density!(grid, p, volume_normalization = true)","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"Next, we compare the preferred (default) log-volume normalization with the standard volume normalization (which is true to the actual density). To identify the individual effect of the peaks, we approximate p_A(x) and p_B(x) individually:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"\ngrid_A = create_grid(LogRange(1e-10,1e-2,100))\napproximate_density!(grid_A, p_A, volume_normalization = true)\n\ngrid_B = create_grid(LogRange(1e-10,1e-2,100))\napproximate_density!(grid_B, p_B, volume_normalization = true)\n\nlv_plot = plot(DensityPlot(grid_A), xaxis = :log, fill = 0, title = \"log-volume\", label = \"peak A\")\nplot!(DensityPlot(grid_B), fill = 0, label = \"peak B\")\n\n\nv_plot = plot(DensityPlot(grid_A), xaxis = :log, volume_normalization = :linear, fill = 0, title = \"volume\", label = \"peak A\")\nplot!(DensityPlot(grid_B), volume_normalization = :linear, fill = 0, label = \"peak B\")\n\nplot(lv_plot, v_plot, layout = (1,2), size = (800,300))","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"With the log-volume normalization both peaks have the same size, suggesting that each peak has the same effect strength w.r.t. to the dose-response curve, albeit at different locations. With the standard volume normalization, however, peak A is significantly larger than peak B, indicating that peak B affects the dose-response curve only marginally. ","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"Since we have approximated grids for each peak individually, as well as for the whole density, it can easily be checked how strong the effect of each peak is, by simulating the corresponding dose-response curves:","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"concentrations = LogRange(1e-10,1e-2, 100)\n\ndr_A = DoseResponseResult(grid_A, concentrations)\ndr_B = DoseResponseResult(grid_B, concentrations)\ndr_total = DoseResponseResult(grid, concentrations)\n\nplot(dr_A, label = \"peak A\", xaxis = :log, legend = :topleft, linewidth = 3)\nplot!(dr_B, label = \"peak B\", linewidth = 3)\nplot!(dr_total, label = \"both peaks\", linewidth = 3)","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"As the log-volume normalized plot suggested, both peaks have the same effect strength w.r.t. to the dose-response curve. The only difference is the location of the effect.","category":"page"},{"location":"DensityPlots/","page":"Density plots for OneDimGrid","title":"Density plots for OneDimGrid","text":"remark: Visualization\nWhile the standard volume normalization shows the true density, the log-volume normalization is more useful for the analysis of dose-response curves.","category":"page"},{"location":"Fitting/#fitting","page":"Fitting","title":"Fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The model generators return a ModelFunctions object. The model field of a ModelFunctions object is a pure Julia function, allowing to implement the model fitting from scratch.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"using AntibodyMethodsDoseResponseConvenience\nmodel, params = accumulation_model(create_grid([1,2,3]))\ntypeof(model.model) <: Function","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Yet, since the model generators create a ModelFunctions object, it is convenient to construct the fitting objective with the FittingObjectiveFunctions package. Then, only the minimization/maximization of the objective function remains to be implemented. Because these steps are always the same, the adaptive_dose_response_fit function summarizes the creation of the model function and the objective function, requiring only the implementation of a function minimizer.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"tip: Reminder: Convenience workflow\nIf there is no reason to avoid the dependencies of the AntibodyMethodsDoseResponseConvenience package, its workflow as described in the quick start guide should be used. FittingCondition and fit_condition expose the same options described here.","category":"page"},{"location":"Fitting/#The-setting","page":"Fitting","title":"The setting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"We consider the following measurement data (concentrations, responses, errors):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_result, data, replicates =  load_results(\"examples/default_concentrations\") # hide\nconcentrations = data.independent # hide\nresponses = data.dependent # hide\nerrors = data.errors # hide\nscatter(concentrations,responses, yerror = errors, xaxis = :log, legend = :none)","category":"page"},{"location":"Fitting/#Simple-model-fitting","page":"Fitting","title":"Simple model fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The data needs to be summarized in a FittingData object, as described in Models:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"data = FittingData(concentrations, responses, errors)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Next, a OneDimGrid needs to be created, ideally covering the concentration range:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"grid = create_grid(LogRange(1e-10,1e-2,40))","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Finally, a function minimizer needs to be implemented. For this, we use the Optim.jl package, here:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"function minimizer(f,∇f,init)\n\tlower = zeros(length(init))\n\tupper = [Inf for i in 1:length(init)]\n\treturn optimize(f,lower,upper, init, Fminbox(NelderMead()),Optim.Options(g_tol = 1e-12, iterations =2000)).minimizer\nend","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The implemented minimizer must take the objective function f, its gradient function ∇f if applicable and an initial parameter array init as arguments and return the minimizing parameters. Furthermore, as K_tau geq 0, the optimization domain should be limited.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Now, a model can be fitted to the data with adaptive_dose_response_fit:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"result = adaptive_dose_response_fit(grid,data,minimizer, options = AdaptiveOptions(model = accumulation_model))","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"result =  deserialize(\"examples/direct_fit/results.jld\") # hide","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_dose_response_fit returns an AdaptiveResult object, that has the following fields:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"optimizer: The estimated parameters (result of model fitting).\nobjective_value: The objective function value for the estimated parameters.\ngrid: A grid containing the estimated parameters as grid weights.\nresult: The DoseResponseResult object corresponding to the grid (and the offset parameter).\ntime: The elapsed time for the model fit (in seconds).","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"scatter(data, xaxis = :log, legend = :topleft, label = \"data\")\nplot!(result.result, label = \"fit result\")","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"plot(DensityPlot(result.grid), xaxis = :log, color = 2, fill = 0, fillalpha = 0.5, label = \"fit result\")","category":"page"},{"location":"Fitting/#adaptive_model_fitting","page":"Fitting","title":"Adaptive model fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The model fit above can be improved in two areas. First, a regularization could be used. Second, the adaptive density approximation from the aptly named AdaptiveDensityApproximation could be used to reduce the number of parameters. Here, we recreate the default optimization from the AntibodyMethodsDoseResponseConvenience package as described in the quick start guide to illustrate some of the available options.","category":"page"},{"location":"Fitting/#Setting-up-the-objective-function-properties","page":"Fitting","title":"Setting up the objective function properties","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"For the regularization, a log-posterior objective can be used, where a smoothing prior defines a regularization. ","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Log-posterior objectives differ from posterior objectives only by taking the logarithm of all functions. Mathematically, there is no difference, but for the computation of tiny probabilities, taking the logarithm upfront is numerically beneficial. Accordingly, the prior also needs to be defined as log-prior, i.e. as the logarithm of the prior.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"While the FittingObjectiveFunctions package expects standard functions as prior/log-prior, adaptive_dose_response_fit requires a prior-generating function (The 500 is used to reproduce the scale = 500 from the quick start guide):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"function log_prior_generator(centers, volumes, offset)\n\tlV = log.(centers .+ volumes/2) .- log.(centers .- volumes/2)\n\tif isnothing(offset)\n\t\treturn λ ->  -500*(sum((λ[i]/lV[i]-λ[i+1]/lV[i+1])^2 for i in 1:length(λ)-1))/length(λ)^2\n\telse\n\t\treturn λ -> -500*(sum((λ[i]/lV[i]-λ[i+1]/lV[i+1])^2 for i in 1:length(λ)-2) + λ[end]^2)/length(λ)^2\n\tend\nend","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The prior generator above will create a new log-prior function for each step of the adaptive fitting. The returned log-prior function reads:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"textlog-prior(lambda) = -frac500textlength(lambda)^2 left(lambda_textoffset + sum_i=1^n-1 left( fraclambda_ilV_i - fraclambda_i+1lV_i+1 right)^2 right)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Since the default density-visualization of grids rescales the weights by using the visual interval lengths in a logarithmic scale (see Background: log-volume normalization), the smoothing should be applied to the rescaled parameters λ. To rescale the parameters, the log-volumes are calculated lV and each parameter λ[i] is divided by the corresponding log-volume lV[i].","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Next, observe that the log-prior is just the logarithm of a normal distribution (up to a missing normalization) for the difference of the rescaled parameters. Essentially, the prior assumes that there is no difference between neighboring parameters where the scale frac500textlength(lambda)^2 expresses the strength/importance of this assumption. This is the aforementioned smoothing.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: Why prior-generator functions?\nUsing log-prior generating functions seems unnecessarily complicated, at first. However, during the adaptive fit, the underlying grid approximation changes, leading to different (visual) interval lengths. Defining a fixed function for the prior could not take the change of interval lengths into account, i.e. the parameters could not be rescaled. Hence, the prior needs to be recalculated after every change of the grid, which requires a function that generates the prior from grid properties centers, volumes and information about the presence of an offset parameter.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Without additional information about the measurement errors, a normal distribution is a sensible choice for the uncertainty distribution. Since the goal is a log-posterior objective, the logarithm of a normal distribution (y,m,Δy)-> -(y-m)^2/Δy^2 should be used:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"data = FittingData(concentrations,responses, errors, distributions = (y,m,Δy)-> -(y-m)^2/Δy^2)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Here, y denotes the data point value, m denotes the model value calculated from the parameters and Δy denotes the measurement error. Uncertainty distributions must take the arguments in this order (y,m,Δy) and must return the distribution / log-distribution value.","category":"page"},{"location":"Fitting/#Setting-up-the-minimizers","page":"Fitting","title":"Setting up the minimizers","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"As before, a minimizer needs to be defined:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"function minimizer(f,∇f,init)\n\tlower = zeros(length(init))\n\tupper = [Inf for i in 1:length(init)]\n\treturn optimize(f,lower,upper, init, Fminbox(NelderMead()),Optim.Options(g_tol = 1e-12, iterations =2000)).minimizer\nend","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: Minimization and log-posterior?\nLikelihood and posterior objectives usually need to be maximized. However, Optim.jl only provides minimizers, as do some other optimization packages, expecting from the user to flip the sign of the function for a maximization. adaptive_dose_response_fit flips the sign of the posterior and log-posterior objectives automatically.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"But, to recreate the default fitting from the AntibodyMethodsDoseResponseConvenience package, a second minimizer is needed (using the LBFGS algorithm):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"function post_minimizer(f,∇f,init)\n\tlower = zeros(length(init))\n\tupper = [Inf for i in 1:length(init)]\n\treturn optimize(f,lower,upper, init, Fminbox(LBFGS()),Optim.Options(g_tol = 1e-12, iterations =2000)).minimizer\nend","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The second minimizer will be applied after the adaptive optimization to fine-tune the results with a gradient based minimizer. ","category":"page"},{"location":"Fitting/#Setting-up-the-options","page":"Fitting","title":"Setting up the options","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Before fitting the data, the fitting options (AdaptiveOptions) and the initial grid need to be defined. Among others, the objective and the prior-generator defined above need to be selected (the additional options in the example are needed to obtain the defaults from the AntibodyMethodsDoseResponseConvenience package):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, iterations = 30, offset = eps(), prior_generator = log_prior_generator)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The idea of the adaptive approximation is to start with a coarse grid, containing only 2 intervals (3 interval edges):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"grid = create_grid(LogRange(1e-10,1e-2,3)) ","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: Adaptive fitting\nWith only 2 parameters, common optimizers find a good minimum even for suboptimal initial parameters. Then, the grid can be refined in regions of interest, e.g. the interval with the largest variation to its neighbors, can be split, thus increasing the resolution of the grid and the number of parameters. Now, the previous result can be used as good initial point for the optimization. This process can be repeated several times, increasing the number intervals for regions of interest while not wasting computation time with small intervals in uninteresting regions.","category":"page"},{"location":"Fitting/#Fitting","page":"Fitting","title":"Fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Now, the data can be fitted with adaptive_dose_response_fit:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_result = adaptive_dose_response_fit(grid,data,minimizer, options = fitting_options)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"To fine-tune the result with the gradient-based minimizer from above, adaptive_dose_response_fit needs to be called again with different options (i.e. no iterations to obtain a single fit and using the offset from the previous result):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"post_options = AdaptiveOptions(objective = :log_posterior, offset = result.optimizer[end], prior_generator = log_prior_generator)\nadaptive_result = adaptive_dose_response_fit(adaptive_result.grid,data,post_minimizer, options = post_options)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_result # hide","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"As before, the dose-response curve is recovered:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"scatter(data, xaxis = :log, legend = :topleft, label = \"data\")\nplot!(adaptive_result.result, label = \"fit result\", color = 3)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"But comparing the estimated densities from the simple model fit and the adaptive model reveals the difference:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"plot(DensityPlot(result.grid), xaxis = :log, color = 2, fill = 0, fillalpha = 0.5, legend = :topleft, label = \"simple fit\")\nplot!(DensityPlot(adaptive_result.grid), color = 3, fill = 0, fillalpha = 0.5, label = \"adaptive fit\")","category":"page"},{"location":"Fitting/#The-same-options-in-the-convenience-workflow","page":"Fitting","title":"The same options in the convenience workflow","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"As mentioned above, the convenience workflow exposes the same options as adaptive_dose_response_fit. Although the adaptive model fitting section uses options that are already the defaults of the convenience workflow, this section creates these options explicitly to illustrate how to modify the options and to illustrate the convenience gain.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"First, the log-prior-generator (with the scale 500) can be obtained with scaled_log_volume_prior:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"using AntibodyMethodsDoseResponseConvenience #hide\nadaptive_result, data, replicates =  load_results(\"examples/default_concentrations\") # hide\nconcentrations = data.independent # hide\nresponses = data.dependent # hide\nerrors = data.errors # hide\nlog_prior_generator = scaled_log_volume_prior(500)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The FittingData object is created as before.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"data = FittingData(concentrations,responses, errors, distributions = (y,m,Δy)-> -(y-m)^2/Δy^2)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The Optim.jl minimizers can be obtained with less boilerplate code, using minimizer_generator:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"minimizer = minimizer_generator(NelderMead())\npost_minimizer = minimizer_generator(LBFGS())","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"In general, the grid is created automatically, based on the concentration range of the dose-response data. However, if one concentration is 0, the automatic grid should not be used.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"grid = create_grid(LogRange(1e-10,1e-2,3)) ","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: automatic grids and concentration `0`\nThe automatic grids are created with the LogRange function and are intended for logarithmic plots. A zero-concentration would lead to a DomainError, as LogRange demands positive numbers. To avoid an error, the automatic grid generator then substitutes eps() for 0 (only for the auto-generated grid) and raise a warning. However, too large grid domains lead to poor fit results. Hence, it is recommended to create the grid manually in those cases.","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The same options as before are used:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, iterations = 30, offset = eps(), prior_generator = log_prior_generator)\npost_options = AdaptiveOptions(objective = :log_posterior, offset = eps(), prior_generator = log_prior_generator)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Finally, the objects, functions and options from above need to be summarized in a FittingCondition object:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"condition = FittingCondition(data,\n\tgrid = grid,\n\toptions_1 = adaptive_options,\n\toptions_2 = post_options,\n\tminimizer_1 = minimizer,\n\tminimizer_2 = post_minimizer\n\t)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Fitting the condition is done by calling fit_condition:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"result = fit_condition(condition)\nplot(DensityPlot(result.grid), xaxis = :log, fill = 0, fillalpha = 0.5)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"plot(DensityPlot(adaptive_result.grid), xaxis = :log, fill = 0, fillalpha = 0.5) #hide","category":"page"},{"location":"Fitting/#Multi-threaded-fitting","page":"Fitting","title":"Multi-threaded fitting","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The fitting of a single condition cannot be parallelized. However, fitting more than one condition can be done in parallel. For an array of FittingCondition objects:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"conditions = [condition_1,condition_2,condition_3]","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"The conditions can be fitted in parallel with fit_conditions (observe the additional s):","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"fit_conditions(conditions)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"info: Multi-threading\nThe number of threads cannot be changed after Julia is launched. The number of threads needs to be set in before, e.g. with julia -t 8 to run Julia with 8 threads. The number of threads can be checked with Threads.nthreads().","category":"page"},{"location":"Fitting/#Changing-the-initial-values","page":"Fitting","title":"Changing the initial values","text":"","category":"section"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"In each case discussed here, no initial parameter values were set for the model fitting. This is, because the wights of the gird are used as initial values. By default, create_grid sets all weights to 1:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"grid = create_grid(LogRange(1e-10,1e-2,3)) \nexport_weights(grid)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Changing the weights of the gird before running the fitting-process allows to specify the initial values for the model fitting. E.g. for the manual definition of adaptive fitting:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"import_weights!(grid,[eps(),1])\nadaptive_result = adaptive_dose_response_fit(grid,data,minimizer, options = fitting_options)","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"Or for the convenience workflow, e.g. after the FittingCondition has already been defined:","category":"page"},{"location":"Fitting/","page":"Fitting","title":"Fitting","text":"import_weights!(condition.grid,[eps(),1])\nresult = fit_condition(condition)","category":"page"},{"location":"Uncertainty/#Uncertainty-estimation","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The posterior and log-posterior objectives (as used in the Fitting tutorial) from the FittingObjectiveFunctions package belong to a Bayesian data analysis approach. In this analysis regime, it is important to consider not only the best fit but also less probable parameters to estimate the uncertainty of the fit result.","category":"page"},{"location":"Uncertainty/#[EpitopeUncertainty](@ref)-construction","page":"Uncertainty estimation","title":"EpitopeUncertainty - construction","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The EpitopeUncertainty type collects and stores the uncertainty of a K_tau-density. To illustrate how to obtain an uncertainty estimation, we consider the adaptive fit results from the Fitting tutorial:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using AntibodyMethodsDoseResponseConvenience# hide\nusing Measures # hide\nadaptive_result, data, replicates =  load_results(\"examples/default_concentrations\") # hide\ndr_plot = scatter(data, xaxis = :log, label = \"data\", legend = :topleft) # hide\nplot!(adaptive_result.result, label = \"adaptive_result.result\") # hide\ndensity_plot = plot(DensityPlot(adaptive_result.grid), xaxis = :log, color = 2, fill = 0, fillalpha = 0.5, label = \"adaptive_result.grid\") # hide\nplot(dr_plot, density_plot, layout = (1,2), size = (800,300), margins = 4mm, legend = :topleft) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"A question of interest could be the uncertainty of the individual peaks. For this, the index-bins belonging to the different peaks need to be identified. Using peak_detection and setting the threshold to 0.01 results in:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"bins, ranges = peak_detection(adaptive_result.grid, 0.01)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"peak_detection returns the identified peaks both as bins (indices of intervals) and the grid-domain ranges. By default, the regions between peaks are also included (fill = true) and the peaks are determined with volume_normalization = :log (see Background: log-volume normalization).","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Info\nFor plotting purposes (bin_analysis_plot, peak_analysis_plot), the bins need to specify the grid-domain ranges, e.g. [[1e-10,1e-8],[1e-5,1e-3]]. For the uncertainty estimation and uncertainty plotting (uncertainty_plot), the bins need to specify the grid intervals that are varied, e.g. [[1,2,3],[5,8]].","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"tip: Tip\nDefining grid-domain ranges is often easier than figuring out which gird intervals belong to these ranges. The select_indices function allows to pick the interval indices belonging to a gird-domain range.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Having defined the interval groups, the uncertainty can be estimated by fixing all parameters to the fit result, shifting uniformly only the parameters belonging to the current group of interest. This process is then repeated for all interval groups. Evaluating the objective function for each shift allows to estimate the uncertainty of the interval group.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"(Image: UncertaintyShift)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"This uncertainty estimation from bin-wise shifting can be obtained with the following EpitopeUncertainty constructor:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, \n\t\tprior_generator = scaled_log_volume_prior(500),\n\t\toffset = adaptive_result.optimizer[end]\n\t\t)\n\neu = EpitopeUncertainty(data,adaptive_result.grid, bins, \n\t\tlevels = [1e-10,1e-5,0.1,0.25,0.5,0.75,0.9,1], \n\t\toptions = adaptive_options\n\t\t)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty/eu.jld\") # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The bin-wise shifting constructor EpitopeUncertainty generates the objective function automatically, using the same methods as adaptive_dose_response_fit, hence the need for an AdaptiveOptions object. In the example above, the options were chosen to match those from the Fitting tutorial section.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Notice the offset = adaptive_result.optimizer[end] line. Since the default fitting algorithm that was recreated in the Fitting tutorial section uses the offset parameter, the estimated offset must be added to the uncertainty estimation, as it shifts up the resulting dose-response curve globally. Recall, that the offset parameter is the last element of the returned optimizer field of an AdaptiveResult object.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Finally, the uncertainty levels are specified as fractions of the best objective value.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: uncertainty estimation from samples\nThere is also an EpitopeUncertainty constructor that uses samples, drawn from a posterior or log-posterior objective. However, the sample constructor does not support the selection of bins. Quantiles corresponding to the chosen levels are calculated for each parameter individually. Furthermore, no sample algorithm is provided by the AntibodyMethods packages.","category":"page"},{"location":"Uncertainty/#[EpitopeUncertainty](@ref)-plotting","page":"Uncertainty estimation","title":"EpitopeUncertainty - plotting","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The AntibodyMethodsDoseResponseRecipes package provides a plotting recipe for EpitopeUncertainty objects. To define the color-gradient for the uncertainty visualization, the Colors.jl package is needed as well. Both packages (and also Plots.jl) are automatically exported by the AntibodyMethodsDoseResponseConvenience package. The EpitopeUncertainty object eu can be plotted by passing the grid adaptive_result.grid and the EpitopeUncertainty object eu to the plot function:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"uncertainty_colors =colormap(\"RdBu\", 8)[end:-1:1]\nplot(adaptive_result.grid, eu, xaxis = :log, legend = :topleft,\n\tcolors = uncertainty_colors, \n\thide_labels = false,\n\tbins = bins\n\t)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The colormap function from Colors.jl creates an array of colors (here 8 colors, which matches the number of uncertainty levels). The [end:-1:1] is used to reverse the colors (now from blue to red). Thus, the lower levels (less certain) are blue while the best result is red.","category":"page"},{"location":"Uncertainty/#Keywords-with-default-arguments","page":"Uncertainty estimation","title":"Keywords with default arguments","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"volume_normalization = :log: The volume-normalization as discussed in Background: log-volume normalization.\ncolors = [:gray]: An array of colors (that Plots.jl accepts for the color keyword) that correspond to the different uncertainty levels. If the array contains less colors than uncertainty levels, the last color is repeated for the remaining levels.\nopacities = [1]: Array of opacities (number between 0 and 1) that correspond to the different uncertainty levels. Again, the last opacity is repeated if there are more uncertainty levels than opacities.\nreverse = false: If true the plotting order of the uncertainty levels is reversed. Since the uncertainty ranges are plotted on top of each other, this can become necessary when the EpitopeUncertainty constructor for samples is used, where larger levels correspond to larger uncertainty (as opposed to the bin-wise shifting constructor). \nhide_labels = true: If true the labels are omitted. Can become necessary when a large number of uncertainty levels is used.\nbins = nothing: Specifies the positions for the bin-markers (dashed lines). The bins should be the same as those used in the EpitopeUncertainty constructor. If nothing, bin markers are omitted.\nbin_color = :gray: Color of the bin markers.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"warning: Interpretation of the uncertainty\nAs explained above, the uncertainty is estimated by keeping all bins fixed, only shifting one bin at a time. Thus, the bin uncertainties have to be considered individually. It is not admissible to combine the uncertainty of the bins: e.g. to consider shifting the first peak up and shifting the second peak down within the 1e-10 uncertainty region and then to declare this to have the uncertainty 1e-10.It is not admissible to consider partial shifts within a bin: e.g. shifting only the tip of the first peak, but not the other parts of the peak. The uncertainty level is only valid for the uniform shift of all parameters within a bin.","category":"page"},{"location":"Uncertainty/#[DoseResponseUncertainty](@ref)-construction","page":"Uncertainty estimation","title":"DoseResponseUncertainty - construction","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Given an EpitopeUncertainty object and the corresponding grid, a DoseResponseUncertainty object can be created. In essence, the dose-response uncertainty is obtained by simulating dose-response curves for the different parameters contained in the EpitopeUncertainty object. Hence, the concentrations that these dose-responses are simulated for need to be passed explicitly:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"concentrations = LogRange(extrema(data.independent)...,100)\ndu = DoseResponseUncertainty(adaptive_result.grid, eu, concentrations, bins = bins)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"du = deserialize(\"examples/uncertainty/du.jld\") # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The same bins that were used to create the EpitopeUncertainty object should also be used for the DoseResponseUncertainty constructor. This is, because the dose-response uncertainty is calculated as point-wise maximum/minimum over the effect of the individual uncertainty-variation of each bin. The following example illustrates the dose-response uncertainties that result from the individual peak uncertainties (dashed lines), both for the same uncertainty level. The green ribbon shows the resulting overall dose-response uncertainty (for the same uncertainty level):","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"concentrations = LogRange(extrema(data.independent)...,100) # hide\n\ngrid_A = deepcopy(adaptive_result.grid) # hide\ngrid_B = deepcopy(adaptive_result.grid) # hide\ncutoff = select_indices(grid_A, lower = 1e-5)[1] # hide\nprintln(cutoff) # hide\n\nweights_A = export_weights(grid_A) # hide\nweights_A[1:cutoff] .= weights_A[1:cutoff] .* 1.2 # hide\nimport_weights!(grid_A, weights_A) # hide\n\nweights_B = export_weights(grid_B) # hide\nweights_B[cutoff:end] .= weights_B[cutoff:end] .* 1.4 # hide\nimport_weights!(grid_B, weights_B) # hide\n\ndr_fit = DoseResponseResult(adaptive_result.grid, concentrations) # hide\ndr_A = DoseResponseResult(grid_A, concentrations) # hide\ndr_B = DoseResponseResult(grid_B, concentrations) # hide\ndr_sum = DoseResponseResult(concentrations, max.(dr_A.responses,dr_B.responses)) # hide\n\nplot(dr_fit, xaxis = :log, color = :red, label = \"best fit\", legend = :topleft, linewidth = 3, xlabel = \"concentration\", ylabel = \"response\") # hide\nplot!(dr_sum, color = :green, label = \"component maxiumum\", linewidth = 0, fill = dr_fit.responses, fillalpha = 0.5) # hide\nplot!(dr_A,  linestyle = :dash, color = :blue, label = \"peak 1 variation\", linewidth = 2.5) # hide\nplot!(dr_B,  linestyle = :dashdotdot, color = \"Blue Violet\", label = \"peak 2 variation\", linewidth = 2.5) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Furthermore, note that concentrations covers the same concentration range as the dose-response data points, but contain much more intermediate concentrations:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"println(data.independent)\nprintln(concentrations)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"tip: Tip\nUsing more intermediate concentrations is recommended to avoid jagged lines.","category":"page"},{"location":"Uncertainty/#[DoseResponseUncertainty](@ref)-plotting","page":"Uncertainty estimation","title":"DoseResponseUncertainty - plotting","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"As before, AntibodyMethodsDoseResponseRecipes provides a plotting recipe for DoseResponseUncertainty objects:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"plot(du, xaxis = :log, legend = :topleft, colors = uncertainty_colors, hide_labels = false)\nscatter!(data, color = \"Dark Orange\", label = \"data\") # compare uncertainty with data","category":"page"},{"location":"Uncertainty/#Keywords-with-default-arguments-2","page":"Uncertainty estimation","title":"Keywords with default arguments","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"filter_zeros = [true, false]: Remove zero-values from the plot (works the same as explained in Measurement data - Plotting).\ncolors = [:gray]: Same as EpitopeUncertainty plotting above\nopacities = [1]: Same as EpitopeUncertainty plotting above\nreverse = false: Same as EpitopeUncertainty plotting above\nhide_labels = true: Same as EpitopeUncertainty plotting above","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"warning: Interpretation of the uncertainty\nAs explained above, the uncertainty is estimated by keeping all bins fixed, only using the uncertainty estimation of one bin at a time. Then, the dose-response curves are simulated. For each concentration, the maximal/minimal value is estimated for all bins.  Thus, comparing the dose-response uncertainty with the uncertainty of an individual peak is not directly possible. It rather shows the worst-case uncertainty if any of the peaks (but only one) would be shifted within a certain uncertainty level.Nevertheless, it is possible to gauge the uncertainty effect of a single peak, by considering only the concentration region of the dose-response curve that matches the K_tau region of the peak.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Why component wise maxima/minima?\nThe component-wise maxima/minima are just a compromised way to combine the uncertainty corresponding to all the individual peaks into a single plot. Using a different plot for each peak would be less confusing, but less concise. Also, the component-wise maxima/minima do not correspond to the overall uncertainty, i.e. when all peaks are shifted within an uncertainty level at the same time. Example: Total uncertainty shows how to obtain the total dose-response uncertainty.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"tip: Different plots for different aspects\nCombining to many aspects into a single plot leads to misinterpretation. Choosing different bins allows to obtain different uncertainty estimations, as the examples below show.","category":"page"},{"location":"Uncertainty/#Plotting-with-[uncertainty_plot](@ref)","page":"Uncertainty estimation","title":"Plotting with uncertainty_plot","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Since the uncertainty estimation involves various subtleties, it is not discussed in the quick start guide. However, the AntibodyMethodsDoseResponseConvenience package contains a convenience function (uncertainty_plot) to create the uncertainty plots with. The available methods to customize the plots are discussed in quick start: plotting options.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The plots from above can be recreated with uncertainty_plot:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"du_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid,\n\t\teu_arguments = eu_options(8, bins, hide_labels = false),\n\t\tdu_arguments = du_options(8, hide_labels = false)\n\t\t)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Both eu_options and du_options expect the number of uncertainty levels as first argument. eu_options takes the bins as second, optional argument. Then, the respective uncertainty-plot keywords discussed above can be added to eu_options and du_options.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"plot(eu_plot)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"plot(du_plot)\nscatter!(data, color = \"Dark Orange\", label = \"data\") # plot data points on top","category":"page"},{"location":"Uncertainty/#Rescale-the-bin-wise-shifts","page":"Uncertainty estimation","title":"Rescale the bin-wise shifts","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"By default (volume_normalization = :none), all weights within the same bin are shifted uniformly. However, the corresponding intervals may have different lengths. And the contribution of an interval is given by the product weight × interval length. Hence, scaling the wight shifts according to their corresponding interval length provides a further uncertainty estimation from bin-wise weight shifting. For this, the volume_normalization = :linear keyword can be used in the EpitopeUncertainty constructor, leading to","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty_volume/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_volume/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 3mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Observe that the shifts become larger for larger K_\\tau values. Although the intervals appear to have the same lengths, the intervals further right in the plot are larger, because of the logarithmic plot. Hence, the shifts, when scaled by the interval length, become larger. Note that this behavior is universal, i.e. not necessarily depending on the uncertainty itself but on the fact of the unequal size of intervals of a logarithmic scale.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"As mentioned in Background: log-volume normalization, it is in fact the visual area of the intervals in the logarithmic plot that corresponds to the dose-response effect of the interval. Thus, scaling the shifts with the visual lengths of the intervals, as they appear in a logarithmic plot, is another approach to investigate the uncertainty with bin-wise weight shifting. This can be achieved by volume_normalization = :log:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty_log_volume/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_log_volume/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 3mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Since the intervals have the about the same length in the logarithmic plot, the shifts are almost identical (for the respective bin).","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Info\nIn summary, the different re-scalings of the shifts provide additional methods to investigate the uncertainty differently. Since bin-wise shifts only approximate the uncertainty roughly (as sampling is computationally expensive), different scalings reveal different aspects of the uncertainty, by testing different configuration of deviation from the best fit. Hence, no scaling is superior to the others, they just answer slightly different questions about the uncertainty.","category":"page"},{"location":"Uncertainty/#of_single_peak","page":"Uncertainty estimation","title":"Example: Uncertainty of a single peak","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The interpretation of the uncertainty plots can be tricky at times, which is addressed by the warnings above. In the example above, it is not possible to compare the dose-response uncertainty with the uncertainty of a single bin. To do so, the uncertainty estimation needs to be restricted to a single peak:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"temp_bins, temp_ranges = peak_detection(adaptive_result.grid, 0.01)\nbins = [temp_bins[2]]\nprintln(bins) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Using [temp_bins[2]] creates a vector of bins, in this case with only a single bin - the second peak from left. Simply using temp_bins[2] will not work; it will create separate bins, each containing only a single element.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Now, the uncertainty estimation proceeds as before:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, \n\t\tprior_generator = scaled_log_volume_prior(500),\n\t\toffset = adaptive_result.optimizer[end]\n\t\t)\n\neu = EpitopeUncertainty(data,adaptive_result.grid, bins, \n\t\tlevels = [1e-10,1e-5,0.1,0.25,0.5,0.75,0.9,1], \n\t\toptions = adaptive_options\n\t\t)\n\nconcentrations = LogRange(extrema(data.independent)...,100)\ndu = DoseResponseUncertainty(adaptive_result.grid, eu, concentrations, bins = bins)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty_single/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_single/du.jld\") # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"These uncertainty objects produce the following plots:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 3mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nIn this case, the uncertainty of the dose-response curve corresponds exclusively to the uncertainty of the middle peak (other uncertainties have not been estimated).","category":"page"},{"location":"Uncertainty/#in_single_peak","page":"Uncertainty estimation","title":"Example: Uncertainty in a single peak","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"In the example above, the use of [temp_bins[2]] was emphasized. Using temp_bins[2] will create single-element bins (that are contained in the bin temp_bin[2]). Internally, single-element arrays are converted to [[elm] for elm in collection].","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"But it is worthwhile to consider this case. It corresponds to the uncertainty of the individual parameters in temp_bin[2], where one parameter at a time is varied, keeping the rest fixed to the best fit result.","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"temp_bins, temp_ranges = peak_detection(adaptive_result.grid, 0.01)\nbins = temp_bins[2]\nprintln(bins) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The uncertainty estimation and plotting work as before:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\neu = deserialize(\"examples/uncertainty_split/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_split/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 3mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nThe same warnings as before apply. The uncertainty of only the individual parameters (in this case) can be deduced from this plot, as is also indicated by the bin markers. It is not valid to combine the uncertainties (e.g. move one parameter up and its neighbor down). Also, the uncertainty of a single parameter cannot be compared directly to the dose-response uncertainty. ","category":"page"},{"location":"Uncertainty/#global_uncertainty","page":"Uncertainty estimation","title":"Example: Global uncertainty","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The example Uncertainty of a single peak indicates how to estimate the global-shift uncertainty:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"bins = [collect(1:length(adaptive_result.grid))]","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The uncertainty estimation and plotting work as before:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\neu = deserialize(\"examples/uncertainty_global/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_global/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 3mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nHere, the complete K_tau-density is shifted (globally). Since this is the only \"bin\", the dose-response uncertainty corresponds directly to this uncertainty. Again, it is not admissible to consider individual parameters/peaks/parts moving in different directions. The result is only valid for global/uniform shifts. ","category":"page"},{"location":"Uncertainty/#individual_uncertainty","page":"Uncertainty estimation","title":"Example: Individual uncertainty","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The example Uncertainty in a single peak indicates how to estimate the uncertainty for all parameters individually:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"bins = collect(1:length(adaptive_result.grid))\nprintln(bins) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"The uncertainty estimation and plotting work as before:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\neu = deserialize(\"examples/uncertainty_total/eu.jld\") # hide\ndu = deserialize(\"examples/uncertainty_total/du.jld\") # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins = collect(1:length(adaptive_result.grid)),  hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 3mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nThe same warnings as before apply. The uncertainty of only the individual parameters (in this case) can be deduced from this plot, as is also indicated by the bin markers. It is not valid to combine the uncertainties (e.g. move one parameter up and its neighbor down). Also, the uncertainty of a single parameter cannot be compared directly to the dose-response uncertainty. ","category":"page"},{"location":"Uncertainty/#total_uncertainty","page":"Uncertainty estimation","title":"Example: Total uncertainty","text":"","category":"section"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"So far, the same bins were used for both the EpitopeUncertainty and the DoseResponseUncertainty. But, this is not a requirement. It is possible to combine different bins to obtain different uncertainty visualizations. For example, this allows to estimate the total uncertainty. For this, the uncertainties of the individual parameters of the K_tau density are estimated as in Example: Individual uncertainty:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"epitope_bins = collect(1:length(adaptive_result.grid))\nprintln(epitope_bins) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"adaptive_options = AdaptiveOptions(objective = :log_posterior, \n\t\tprior_generator = scaled_log_volume_prior(500),\n\t\toffset = adaptive_result.optimizer[end]\n\t\t)\n\neu = EpitopeUncertainty(data,adaptive_result.grid, epitope_bins, \n\t\tlevels = [1e-10,1e-5,0.1,0.25,0.5,0.75,0.9,1], \n\t\toptions = adaptive_options\n\t\t)\n","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"eu = deserialize(\"examples/uncertainty_total/eu.jld\") # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"Then, the DoseResponseUncertainty is constructed but with the global bin from Example: Global uncertainty:","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"dr_bins = [collect(1:length(adaptive_result.grid))]\nconcentrations = LogRange(extrema(data.independent)...,100)\ndu = DoseResponseUncertainty(adaptive_result.grid, eu, concentrations, bins = dr_bins)","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"using Measures # hide\n\ndu_plot, eu_plot = uncertainty_plot(eu,du,adaptive_result.grid, eu_arguments = eu_options(8, bins = epitope_bins,  hide_labels = false), du_arguments = du_options(8, hide_labels = false)) # hide\n\ndu_plot = plot(du_plot) # hide\nscatter!(data, color = \"Dark Orange\", label = \"data\") # hide\n\nplot(eu_plot, du_plot, layout = (1,2), size = (800,300), margins = 3mm) # hide","category":"page"},{"location":"Uncertainty/","page":"Uncertainty estimation","title":"Uncertainty estimation","text":"info: Interpretation\nFor the uncertainty of the K_tau-density, the interpretation of the uncertainty levels is the same as before in Example: Individual uncertainty and Example: Uncertainty in a single peak. Only a single parameter at a time can be considered while keeping the other parameters fixed to the best fit result.However, the correspondence between the dose-response uncertainty and the density uncertainty is different. An uncertainty level in the dose-response plot now corresponds to any parameter combination in the density plot that is withing the same uncertainty level.","category":"page"},{"location":"AdaptiveDensityApproximation/#AdaptiveDensityApproximation","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/#About","page":"AdaptiveDensityApproximation","title":"About","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"This package introduces the Grid and OneDimGrid types that approximate density functions. The grids can be refined adaptively, i.e. depending on the  location of the strongest density variation. Simple calculations like sums and products of approximated coefficients and integrals of approximated densities are implemented.","category":"page"},{"location":"AdaptiveDensityApproximation/#Installation","page":"AdaptiveDensityApproximation","title":"Installation","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"This package is not in the general registry and needs to be installed from the GitHub repository by:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using Pkg\nPkg.add(url=\"https://github.com/AntibodyPackages/AdaptiveDensityApproximation\")","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"After the installation, the package can be used like any other package:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Plotting grids\nThis package does not include any plotting methods, to reduce the dependencies. However, the package AdaptiveDensityApproximationRecipes contains plotting recipes for Plots.jl. Again, the package is not in the general registry and needs to be installed from the GitHub repository:using Pkg\nPkg.add(url=\"https://github.com/AntibodyPackages/AdaptiveDensityApproximationRecipes\")","category":"page"},{"location":"AdaptiveDensityApproximation/#1-dim-example","page":"AdaptiveDensityApproximation","title":"1-dim example","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In the following, the methods of this package are illustrated on simple, 1-dimensional examples. In some but not all cases tips and additional information are given. For a full documentation of the methods, see the API","category":"page"},{"location":"AdaptiveDensityApproximation/#Construct-grid-and-approximate-densities","page":"AdaptiveDensityApproximation","title":"Construct grid and approximate densities","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The first step is to create a new one-dimensional grid. For this, axis-ticks need to be defined, i.e. the start/endpoints of the intervals:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation, AdaptiveDensityApproximationRecipes, Plots\ngrid = create_grid(LinRange(0,2*pi,10))","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The grid can be used to approximate a function f with approximate_density!(grid,f):","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"approximate_density!(grid,sin)\nplot(grid)\nplot!(sin,color = :red, xlims = [0,2*pi], linewidth = 3)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Approximation options\nThe density is approximated by evaluating the function f at the center points of the grid. But in some cases, it can be desireable to approximate the density using different evaluation points. The following keywords allow to modify the approximation points:mode = :mean: Use the average from the endpoints of the interval / corner points of the block.\nmode = :mesh: Use the average from a mesh of intermediate points.\nmesh_size = n: If mode = :mesh use n intermediate points (per dimension). The default is 4.It is also possible to approximate the area under the graph of a density (function value × block volume) by using volume_normalization = true.","category":"page"},{"location":"AdaptiveDensityApproximation/#Accessing-information-of-the-grid","page":"AdaptiveDensityApproximation","title":"Accessing information of the grid","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Essentially, a grid is just a collection of values (the weights), together with location information (the blocks of the grid). This data can be exported to allow for a convenient implementation of advanced calculations not covered by this package. The weights can be retrieved by","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"export_weights(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Alternatively, the full information can be exported:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"centers, volumes, weights = export_all(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The reverse direction, the import of weights is is also possible (at least for the weights):","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"import_weights!(grid, collect(1:9))\nplot(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Order of blocks\nFor export and import, the intervals/blocks are ordered by their center point. For multidimensional grids, the order is component wise (first dimension precedes second dimension precedes third dimension ...).","category":"page"},{"location":"AdaptiveDensityApproximation/#Refine-the-grid","page":"AdaptiveDensityApproximation","title":"Refine the grid","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The grid can be refined (subdividing the blocks that have the largest weight differences to their neighbors) with:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"refine!(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Info\nA block is subdivided into 2^dim equally-sized subdividing blocks. E.g. an interval is split in the middle into two intervals, a square is split into 4 quatring squares, etc.. ","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The functions approximate_density! and refine! can be used together in a loop to refine the grid adaptively.","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid([0,pi/2,pi,3*pi/2,2*pi])\n\nanimation = @animate for i in 1:30\n\tplot(grid)\n\tapproximate_density!(grid,sin)\n\trefine!(grid)\nend\ngif(animation,fps=2)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Custom variation and block selection\nThe refine process is a two-step process. First, each block is assigned a variation value. The default variation is the largest absolut weight difference to the neighboring blocks. Then, based on the variation values, the blocks that will be subdivided further are selected (largest variation value by default). It is possible to redefine the block variation assignment and the selection:block_variation: Function to calculate the variation value for a block. Must use the following signature (block_center,block_volume, block_weight, neighbor_center,neighbor_volumes, neighbor_weights).\nselection: Function to select the appropriate variation value(s) from. Must have the signature (variations)  where variations is a one-dim array of the variation values.","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Weight splitting\nThe subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).","category":"page"},{"location":"AdaptiveDensityApproximation/#Restriction-of-grid-domain","page":"AdaptiveDensityApproximation","title":"Restriction of grid domain","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"For some applications it can be useful to restrict a grid (temporarily) for certain calculations. Consider, for example, a grid that approximates x->x^2 on the domain [-1,1]:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid(LinRange(-1,1,50))\napproximate_density!(grid,x-> x^2)\nplot(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"A reasonable domain restriction could be to only allow positive numbers for x, i.e. to restrict the grid to [0,1]:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"restrict_domain!(grid,lower = 0)\nplot(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/#Simple-calculations:-Sums,-products-and-integrals","page":"AdaptiveDensityApproximation","title":"Simple calculations: Sums, products and integrals","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Some simple operations are pre-defined for grids (no need to export weights, etc.). For example, the sum of the weights can easily be obtained:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"sum(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"It is also possible to apply a function to all weights before they get summed up / get multiplied together. Furthermore, the grid domain can be restricted temporarily (not mutating the grid).","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"prod(x-> log(x),grid, lower = 0.5)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"A grid can also be used for the approximation of an integral. In the case of the restricted grid from above, approximating xmapsto x^2 on 01, the integral int_0^1 x^2 dx overset= frac13 is approximated:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"integrate(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/#Advanced-calculations:-Integral-models","page":"AdaptiveDensityApproximation","title":"Advanced calculations: Integral models","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"A more flexible method of integration is the construction of integral models. Consider the general model","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"\tint f(xtauvarphi(tau))  dtau","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"for a density function varphi. When the density function is approximated by a grid, i.e. by intervals I_j with centers c(I_j), volumes textvol(I_j) and heights h(I_j)approx varphi(c(I_j)), the model can be approximated with","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"\tint f(xtauvarphi(tau))  dtau approx sum_j f(xc(I_j) h(I_j)ldots)cdot textvol(I_j)  ","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In general, the implementation of such a model requires a function f(x,τ,φ(τ),...) and a grid that approximates the density φ. The model can then be obtained with integral_model(grid,f). More precisely:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"<div style=\" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px \">","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"@doc integral_model #hide","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"</div> <br>","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"For example, consider f(x,τ,φ(τ)) = cos(τ * x) * φ(τ) for φ(τ) = sin(τ) on [0,2π]:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"int_0^2pi cos(taucdot x)  cdot textsin(tau)  dtau  ","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In particular, it holds that:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"int_0^2pi cos(taucdot 1)  cdot textsin(tau)  dtau = 0 ","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid(LinRange(0,2*pi,30))\napproximate_density!(grid,sin)\nf(x,τ,φ) = cos(τ*x)*φ\nmodel,weights, components = integral_model(grid,f)\nmodel(1,weights)","category":"page"},{"location":"AdaptiveDensityApproximation/#Numeric-PDF-and-CDF","page":"AdaptiveDensityApproximation","title":"Numeric PDF and CDF","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"When the grid approximates a probability density, i.e. a positive density function, numeric PDF anc CDF functions can be obtained as julia functions.","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"p(x) = 1/sqrt(2*pi) * exp(-x^2/2)\ngrid = create_grid(LinRange(-10,10,100))\napproximate_density!(grid,p)\nplot(grid)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The numeric pdf can be obtained with ","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"<div style=\" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px \">","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"@doc get_pdf #hide","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"</div> <br>","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The numeric cdf can be obtained with ","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"<div style=\" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px \">","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"@doc get_cdf #hide","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"</div> <br>","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"For example:","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"cdf = get_cdf(grid)\n\nplot(cdf, fill = 0, legend = :none)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"warning: Warning\nThe function get_pdf and get_cdf do not check if the weights of the blocks are positive. Negative values can lead to unexpected behavior, e.g. division by zero because of the normalization 1/sum(weights).","category":"page"},{"location":"AdaptiveDensityApproximation/#Simple-2-dim-example","page":"AdaptiveDensityApproximation","title":"Simple 2-dim example","text":"","category":"section"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In general, the methods introduced so far are defined for grids of arbitrary dimensions (except for plotting recipes):","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation, Plots\n\ngrid = create_grid([0,pi,2*pi],[0,pi,2pi])\nf(x) = sin(x[1])^2 + cos(x[2])^2\n\nanimation = @animate for i in 1:100\n\tplot(grid)\n\tapproximate_density!(grid,f)\n\trefine!(grid)\nend\ngif(animation, fps = 4)","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"(Image: )","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"It is possible to get a lower-dimensional slice from a higher-dimensional grid (slice along the x-axis at y=3 in this case):","category":"page"},{"location":"AdaptiveDensityApproximation/","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid([0,pi,2*pi],[0,pi,2pi]) #hide\nf(x) = sin(x[1])^2 + cos(x[2])^2 #hide\n\nfor i in 1:100 #hide\n\tapproximate_density!(grid,f) #hide\n\trefine!(grid) #hide\nend #hide\n\nslice = get_slice(grid,[nothing,3])\nplot(slice)","category":"page"},{"location":"#AntibodyMethodsDoseResponse","page":"Introduction","title":"AntibodyMethodsDoseResponse","text":"","category":"section"},{"location":"#About","page":"Introduction","title":"About","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package implements methods to analyze rate-constant distributions for (antibody-binding) dose-response curves, keeping the dependencies as minimal as possible. This assures the most general compatibility and allows to define the analysis from scratch.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"info: Convenience package\nFor most users, this minimal approach and the additional flexibility may not be very useful. Instead, the AntibodyMethodsDoseResponseConvenience package should be preferred, as it pre-defines the recommended analyses and implements the necessary functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In essence, the dose-response data is modelled by the following accumulation model (see https://arxiv.org/abs/2407.06052 for further details):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"r(a) = int_0^infty g(K_tau) left(1- e^-fracaK_tau right)  dK_tau","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where K_tau sim frac1k_texton is proportionally inverse to the binding rate k_texton and g(K_tau) is the K_tau-density (amount) of epitopes that exhibit the rate constant K_tau. Alternatively, the Langmuir isotherm (equilibrium model) can be used. In either case, the analysis consists of a model fit, estimating the density g(K_tau) from measurement data:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using AntibodyMethodsDoseResponseConvenience, Measures # hide\nresults, data, replicates =  load_results(\"examples/default_concentrations\") # hide\ndr_plot, density_plot = bin_analysis_plot(results,data,replicates) # hide\nplot(dr_plot, density_plot, layout = (1,2), size = (800,300), margins = 4mm) # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this documentation, both the terms density plot and histogram will be used interchangeably to refer to the plot of the estimated density g(K_tau).","category":"page"},{"location":"#About-the-tutorials","page":"Introduction","title":"About the tutorials","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The quick start guide \nA minimal tutorial, covering only the necessary steps to analyze dose-response data without any in-depth explanations. \nFrom here, the AnitbodyMethodsDoseResponseConvenience API is highly recommended to explore the additional options of the convenience functions that are not covered in the minimal tutorial.\nThe recommendation for most users.\nThe Detailed explanations\nCovers the background and the internals of this package. \nAssumes (at some points) to be read in order from top to bottom.\nThe convenience functions (from the quick start guide) use the same data types and methods internally.\nIntended for developers that need access to the internal methods and that want to take full control over the analysis.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The AntibodyMethods packages are not part of the official registry. Thus, the installation differs slightly from the usual package installation process.","category":"page"},{"location":"#Simple-installation","page":"Introduction","title":"Simple installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Open the Julia repl and press ] to enter the package manger.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version ****\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\npkg>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For a fresh install of Julia, make sure to add the official registry General first:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> registry add General","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Next, add the AntibodyPackagesRegistry:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> registry add https://github.com/AntibodyPackages/AntibodyPackagesRegistry","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, add AntibodyMethodsDoseResponseConvenience, which install the necessary dependencies:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add AntibodyMethodsDoseResponseConvenience","category":"page"},{"location":"#Manual-installation","page":"Introduction","title":"Manual installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"It is also possible to install the dependencies for AntibodyMethodsDoseResponse manually, with the following commands (exactly in the order below):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/AntibodyPackages/FittingObjectiveFunctions\")\nPkg.add(url=\"https://github.com/AntibodyPackages/AdaptiveDensityApproximation\")\nPkg.add(url=\"https://github.com/AntibodyPackages/AntibodyMethodsDoseResponse\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To install the AntibodyMethodsDoseResponseConvenience package manually, two additional packages need to be installed:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pkg.add(url=\"https://github.com/AntibodyPackages/AntibodyMethodsDoseResponseRecipes\")\nPkg.add(url=\"https://github.com/AntibodyPackages/AntibodyMethodsDoseResponseConvenience\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"info: Info\nAntibodyMethodsDoseResponseRecipes contains plotting instructions for Plots.jl, allowing to plot the data structures defined/used in AntibodyMethodsDoseResponse.","category":"page"},{"location":"#How-to-cite-the-package","page":"Introduction","title":"How to cite the package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you would like to cite this package for scientific purposes, you might also want to cite the corresponding paper https://arxiv.org/abs/2407.06052.","category":"page"}]
}
